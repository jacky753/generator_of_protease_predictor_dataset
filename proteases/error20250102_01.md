(base) C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git>python "01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py"
<_csv.reader object at 0x000001712E321E20>
['A01.001', 'A01.003', 'A01.004', 'A01.007', 'A01.009', 'A01.010', 'A01.041', 'A01.046', 'A01.057', 'A01.070', 'A01.071', 'A01.083', 'A01.A96', 'A01.P01', 'A01.P02', 'A02.010', 'A02.011', 'A02.019', 'A02.024', 'A02.053', 'A02.055', 'A02.056', 'A02.057', 'A02.P01', 'A02.P02', 'A02.P03', 'A02.P04', 'A02.P05', 'A02.P06', 'A02.P07', 'A02.P08', 'A02.P09', 'A02.P10', 'A02.P11', 'A02.P12', 'A02.P13', 'A02.P14', 'A02.P15', 'A02.P16', 'A02.P17', 'A02.P18', 'A02.P19', 'A02.P20', 'non-peptidase homologue', 'unassigned', 'A28.001', 'A28.002', 'A28.003', 'A28.004', 'A28.A10', 'A22.001', 'A22.002', 'A22.003', 'A22.004', 'A22.005', 'A22.006', 'A22.007', 'A22.P01', 'A22.P02', 'C01.009', 'C01.013', 'C01.018', 'C01.032', 'C01.034', 'C01.035', 'C01.036', 'C01.037', 'C01.040', 'C01.060', 'C01.070', 'C01.084', 'C01.973', 'C01.975', 'C01.P02', 'C01.P03', 'C01.P04', 'C01.P07', 'C01.P08', 'C02.001', 'C02.002', 'C02.004', 'C02.006', 'C02.007', 'C02.011', 'C02.013', 'C02.017', 'C02.018', 'C02.020', 'C02.021', 'C02.029', 'C02.031', 'C02.971', 'C02.972', 'C101.001', 'C101.950', 'C110.001', 'C111.001', 'C111.002', 'C111.003', 'C111.004', 'C111.005', 'C111.006', 'C111.007', 'C111.008', 'C111.009', 'C111.950', 'C115.001', 'C115.002', 'C12.001', 'C12.003', 'C12.004', 'C12.005', 'C121.001', 'C121.002', 'C19.001', 'C19.009', 'C19.010', 'C19.011', 'C19.012', 'C19.013', 'C19.014', 'C19.015', 'C19.016', 'C19.017', 'C19.018', 'C19.019', 'C19.020', 'C19.021', 'C19.022', 'C19.023', 'C19.024', 'C19.025', 'C19.026', 'C19.028', 'C19.030', 'C19.034', 'C19.035', 'C19.037', 'C19.040', 'C19.041', 'C19.042', 'C19.044', 'C19.046', 'C19.047', 'C19.048', 'C19.052', 'C19.053', 'C19.054', 'C19.055', 'C19.056', 'C19.057', 'C19.058', 'C19.059', 'C19.060', 'C19.064', 'C19.065', 'C19.067', 'C19.068', 'C19.069', 'C19.070', 'C19.071', 'C19.072', 'C19.073', 'C19.078', 'C19.080', 'C19.081', 'C19.106', 'C19.107', 'C19.108', 'C19.972', 'C19.974', 'C19.978', 'C19.984', 'C19.985', 'C19.986', 'C19.987', 'C19.A82', 'C19.A83', 'C19.A84', 'C19.A85', 'C19.A86', 'C19.A87', 'C19.A88', 'C19.A89', 'C19.A90', 'C19.A91', 'C19.A92', 'C19.A93', 'C19.A94', 'C19.A95', 'C19.A96', 'C19.A97', 'C19.P01', 'C19.P02', 'C19.P05', 'C54.002', 'C54.003', 'C54.004', 'C54.005', 'C64.001', 'C64.002', 'C64.003', 'C64.004', 'C64.006', 'C65.001', 'C65.002', 'C67.001', 'C78.001', 'C78.002', 'C78.003', 'C85.001', 'C85.003', 'C85.004', 'C85.005', 'C85.007', 'C85.008', 'C85.009', 'C85.P01', 'C86.001', 'C86.002', 'C86.004', 'C86.005', 'C98.001', 'C13.002', 'C13.004', 'C13.005', 'C13.P01', 'C14.001', 'C14.003', 'C14.004', 'C14.005', 'C14.006', 'C14.007', 'C14.008', 'C14.009', 'C14.010', 'C14.011', 'C14.018', 'C14.026', 'C14.028', 'C14.029', 'C14.971', 'C14.976', 'C14.A09', 'C14.P01', 'C14.P02', 'C50.002', 'C50.P01', 'C48.002', 'C48.003', 'C48.004', 'C48.007', 'C48.008', 'C48.009', 'C48.011', 'C48.012', 'C15.010', 'C15.011', 'C97.001', 'C97.002', 'I100.001', 'I100.002', 'I103.001', 'I103.UPW', 'M01.001', 'M01.003', 'M01.004', 'M01.010', 'M01.011', 'M01.018', 'M01.022', 'M01.024', 'M01.026', 'M01.028', 'M01.972', 'M02.001', 'M02.004', 'M02.006', 'M02.972', 'M03.001', 'M03.002', 'M03.006', 'M03.971', 'M08.003', 'M08.005', 'M10.001', 'M10.002', 'M10.003', 'M10.004', 'M10.005', 'M10.006', 'M10.007', 'M10.008', 'M10.009', 'M10.013', 'M10.014', 'M10.015', 'M10.016', 'M10.017', 'M10.019', 'M10.021', 'M10.022', 'M10.023', 'M10.024', 'M10.026', 'M10.027', 'M10.029', 'M10.030', 'M10.950', 'M10.971', 'M10.973', 'M100.001', 'M12.002', 'M12.004', 'M12.005', 'M12.016', 'M12.018', 'M12.021', 'M12.024', 'M12.025', 'M12.026', 'M12.027', 'M12.028', 'M12.029', 'M12.208', 'M12.209', 'M12.210', 'M12.212', 'M12.214', 'M12.215', 'M12.217', 'M12.218', 'M12.219', 'M12.220', 'M12.221', 'M12.222', 'M12.224', 'M12.225', 'M12.226', 'M12.230', 'M12.231', 'M12.232', 'M12.234', 'M12.235', 'M12.237', 'M12.241', 'M12.244', 'M12.245', 'M12.246', 'M12.301', 'M12.950', 'M12.956', 'M12.957', 'M12.960', 'M12.962', 'M12.963', 'M12.964', 'M12.975', 'M12.976', 'M12.978', 'M12.979', 'M12.981', 'M12.983', 'M12.987', 'M12.990', 'M12.996', 'M12.P01', 'M12.P02', 'M12.P03', 'M13.001', 'M13.002', 'M13.003', 'M13.007', 'M13.008', 'M13.090', 'M13.091', 'M41.006', 'M41.007', 'M41.016', 'M41.026', 'M41.A19', 'M43.004', 'M43.005', 'M48.003', 'M48.017', 'M49.001', 'M49.972', 'M49.P01', 'M54.002', 'M54.003', 'M76.001', 'M87.001', 'M87.002', 'M87.003', 'M98.A03', 'M14.001', 'M14.002', 'M14.003', 'M14.004', 'M14.005', 'M14.006', 'M14.009', 'M14.010', 'M14.011', 'M14.012', 'M14.016', 'M14.017', 'M14.018', 'M14.020', 'M14.021', 'M14.025', 'M14.026', 'M14.027', 'M14.028', 'M14.029', 'M14.030', 'M14.039', 'M14.950', 'M14.951', 'M14.955', 'M16.002', 'M16.005', 'M16.009', 'M16.971', 'M16.973', 'M16.974', 'M16.981', 'M16.982', 'M16.983', 'M16.984', 'M16.987', 'M16.P01', 'M17.001', 'M17.005', 'M17.006', 'M24.002', 'M24.005', 'M24.007', 'M24.009', 'M24.017', 'M24.026', 'M24.028', 'M24.950', 'M24.973', 'M24.974', 'M24.975', 'M24.976', 'M24.977', 'M18.002', 'M20.005', 'M20.006', 'M20.011', 'M20.021', 'M20.973', 'M28.010', 'M28.011', 'M28.012', 'M28.014', 'M28.016', 'M28.018', 'M28.972', 'M28.973', 'M28.974', 'M28.975', 'M28.978', 'M19.001', 'M19.002', 'M19.004', 'M38.972', 'M38.973', 'M38.974', 'M38.975', 'M38.976', 'M38.977', 'M38.978', 'M38.979', 'M38.980', 'M38.981', 'M50.001', 'M67.002', 'M67.003', 'M67.004', 'M67.005', 'M67.006', 'M67.008', 'M67.011', 'M67.971', 'M67.972', 'M67.973', 'M67.974', 'M67.975', 'M67.A10', 'S01.010', 'S01.011', 'S01.015', 'S01.017', 'S01.019', 'S01.020', 'S01.021', 'S01.028', 'S01.029', 'S01.033', 'S01.034', 'S01.047', 'S01.054', 'S01.072', 'S01.074', 'S01.075', 'S01.078', 'S01.079', 'S01.081', 'S01.085', 'S01.087', 'S01.088', 'S01.105', 'S01.127', 'S01.131', 'S01.132', 'S01.133', 'S01.134', 'S01.135', 'S01.139', 'S01.140', 'S01.143', 'S01.146', 'S01.147', 'S01.152', 'S01.153', 'S01.154', 'S01.155', 'S01.156', 'S01.157', 'S01.159', 'S01.160', 'S01.161', 'S01.162', 'S01.174', 'S01.189', 'S01.191', 'S01.192', 'S01.193', 'S01.194', 'S01.196', 'S01.198', 'S01.199', 'S01.205', 'S01.206', 'S01.211', 'S01.212', 'S01.213', 'S01.214', 'S01.215', 'S01.216', 'S01.217', 'S01.218', 'S01.223', 'S01.224', 'S01.228', 'S01.229', 'S01.231', 'S01.232', 'S01.233', 'S01.236', 'S01.237', 'S01.244', 'S01.246', 'S01.247', 'S01.251', 'S01.252', 'S01.256', 'S01.257', 'S01.258', 'S01.277', 'S01.278', 'S01.284', 'S01.285', 'S01.286', 'S01.291', 'S01.292', 'S01.298', 'S01.299', 'S01.300', 'S01.302', 'S01.306', 'S01.307', 'S01.308', 'S01.309', 'S01.311', 'S01.313', 'S01.318', 'S01.319', 'S01.320', 'S01.321', 'S01.322', 'S01.325', 'S01.326', 'S01.327', 'S01.362', 'S01.365', 'S01.374', 'S01.375', 'S01.376', 'S01.394', 'S01.395', 'S01.414', 'S01.436', 'S01.487', 'S01.488', 'S01.514', 'S01.530', 'S01.531', 'S01.933', 'S01.934', 'S01.940', 'S01.941', 'S01.957', 'S01.969', 'S01.971', 'S01.972', 'S01.974', 'S01.975', 'S01.976', 'S01.979', 'S01.985', 'S01.989', 'S01.992', 'S01.993', 'S01.994', 'S01.998', 'S01.999', 'S01.B93', 'S01.P08', 'S01.P09', 'S01.P10', 'S01.P11', 'S01.P19', 'C44.001', 'C44.970', 'C44.972', 'C44.973', 'C44.974', 'C69.003', 'C69.004', 'C69.005', 'C89.001', 'C89.002', 'C95.001', 'P02.001', 'P02.002', 'P02.003', 'P02.005', 'P02.006', 'P02.007', 'P02.008', 'P02.009', 'P02.010', 'P02.011', 'P02.013', 'P02.014', 'P02.015', 'P02.016', 'P02.017', 'P02.018', 'P02.019', 'P02.020', 'P02.021', 'P02.022', 'P02.023', 'P02.024', 'P02.025', 'P02.026', 'P02.027', 'P02.028', 'P02.029', 'P02.036', 'P02.038', 'P02.039', 'P02.041', 'P02.042', 'T01.010', 'T01.011', 'T01.012', 'T01.013', 'T01.014', 'T01.015', 'T01.016', 'T01.017', 'T01.020', 'T01.971', 'T01.972', 'T01.973', 'T01.974', 'T01.975', 'T01.976', 'T01.977', 'T01.978', 'T01.983', 'T01.984', 'T01.986', 'T01.987', 'T01.991', 'T01.P02', 'T01.P03', 'T02.001', 'T02.002', 'T02.004', 'T03.002', 'T03.006', 'T03.015', 'T03.016', 'T03.017', 'T03.018', 'T03.019', 'T03.021', 'T03.024', 'T03.971', 'C26.001', 'C26.950', 'C26.951', 'C26.952', 'C26.964', 'C26.966', 'C26.A36', 'C56.002', 'C56.003', 'C56.971', 'C56.972', 'C56.974', 'C56.975', 'C46.002', 'C46.003', 'C46.004', 'S68.001', 'S68.002', 'S71.001', 'S71.002', 'S72.001', 'S79.001', 'S79.002', 'S08.039', 'S08.063', 'S08.071', 'S08.072', 'S08.073', 'S08.074', 'S08.075', 'S08.076', 'S08.077', 'S08.A56', 'S53.003', 'S09.001', 'S09.003', 'S09.004', 'S09.007', 'S09.015', 'S09.018', 'S09.019', 'S09.025', 'S09.027', 'S09.051', 'S09.052', 'S09.053', 'S09.055', 'S09.061', 'S09.062', 'S09.065', 'S09.068', 'S09.939', 'S09.941', 'S09.942', 'S09.943', 'S09.944', 'S09.958', 'S09.959', 'S09.960', 'S09.973', 'S09.974', 'S09.977', 'S09.978', 'S09.979', 'S09.980', 'S09.981', 'S09.982', 'S09.984', 'S09.985', 'S09.986', 'S09.987', 'S09.988', 'S09.989', 'S09.990', 'S09.991', 'S09.992', 'S09.993', 'S09.994', 'S09.995', 'S09.A49', 'S09.A50', 'S09.B13', 'S10.002', 'S10.003', 'S10.013', 'S28.001', 'S28.002', 'S28.003', 'S33.011', 'S33.012', 'S33.013', 'S33.017', 'S33.018', 'S33.019', 'S33.020', 'S33.971', 'S33.972', 'S33.973', 'S33.974', 'S33.975', 'S33.976', 'S33.978', 'S33.979', 'S33.981', 'S33.982', 'S33.983', 'S33.984', 'S33.986', 'S33.987', 'S33.988', 'S33.989', 'S33.997', 'S12.004', 'S12.012', 'S26.002', 'S26.009', 'S26.010', 'S26.022', 'S26.A09', 'S21.A01', 'S16.002', 'S16.006', 'S14.003', 'S41.950', 'S41.951', 'S41.956', 'S74.003', 'S59.001', 'S59.951', 'S60.001', 'S60.970', 'S60.972', 'S60.973', 'S60.974', 'S60.975', 'S60.976', 'S60.977', 'S54.002', 'S54.005', 'S54.006', 'S54.008', 'S54.009', 'S54.951', 'S54.952', 'S54.953', 'S54.955']
merops_code_mece
['A01.001', 'A01.003', 'A01.004', 'A01.007', 'A01.009', 'A01.010', 'A01.041', 'A01.046', 'A01.057', 'A01.070', 'A01.071', 'A01.083', 'A01.A96', 'A01.P01', 'A01.P02', 'A02.010', 'A02.011', 'A02.019', 'A02.024', 'A02.053', 'A02.055', 'A02.056', 'A02.057', 'A02.P01', 'A02.P02', 'A02.P03', 'A02.P04', 'A02.P05', 'A02.P06', 'A02.P07', 'A02.P08', 'A02.P09', 'A02.P10', 'A02.P11', 'A02.P12', 'A02.P13', 'A02.P14', 'A02.P15', 'A02.P16', 'A02.P17', 'A02.P18', 'A02.P19', 'A02.P20', 'non-peptidase homologue', 'unassigned', 'A28.001', 'A28.002', 'A28.003', 'A28.004', 'A28.A10', 'A22.001', 'A22.002', 'A22.003', 'A22.004', 'A22.005', 'A22.006', 'A22.007', 'A22.P01', 'A22.P02', 'C01.009', 'C01.013', 'C01.018', 'C01.032', 'C01.034', 'C01.035', 'C01.036', 'C01.037', 'C01.040', 'C01.060', 'C01.070', 'C01.084', 'C01.973', 'C01.975', 'C01.P02', 'C01.P03', 'C01.P04', 'C01.P07', 'C01.P08', 'C02.001', 'C02.002', 'C02.004', 'C02.006', 'C02.007', 'C02.011', 'C02.013', 'C02.017', 'C02.018', 'C02.020', 'C02.021', 'C02.029', 'C02.031', 'C02.971', 'C02.972', 'C101.001', 'C101.950', 'C110.001', 'C111.001', 'C111.002', 'C111.003', 'C111.004', 'C111.005', 'C111.006', 'C111.007', 'C111.008', 'C111.009', 'C111.950', 'C115.001', 'C115.002', 'C12.001', 'C12.003', 'C12.004', 'C12.005', 'C121.001', 'C121.002', 'C19.001', 'C19.009', 'C19.010', 'C19.011', 'C19.012', 'C19.013', 'C19.014', 'C19.015', 'C19.016', 'C19.017', 'C19.018', 'C19.019', 'C19.020', 'C19.021', 'C19.022', 'C19.023', 'C19.024', 'C19.025', 'C19.026', 'C19.028', 'C19.030', 'C19.034', 'C19.035', 'C19.037', 'C19.040', 'C19.041', 'C19.042', 'C19.044', 'C19.046', 'C19.047', 'C19.048', 'C19.052', 'C19.053', 'C19.054', 'C19.055', 'C19.056', 'C19.057', 'C19.058', 'C19.059', 'C19.060', 'C19.064', 'C19.065', 'C19.067', 'C19.068', 'C19.069', 'C19.070', 'C19.071', 'C19.072', 'C19.073', 'C19.078', 'C19.080', 'C19.081', 'C19.106', 'C19.107', 'C19.108', 'C19.972', 'C19.974', 'C19.978', 'C19.984', 'C19.985', 'C19.986', 'C19.987', 'C19.A82', 'C19.A83', 'C19.A84', 'C19.A85', 'C19.A86', 'C19.A87', 'C19.A88', 'C19.A89', 'C19.A90', 'C19.A91', 'C19.A92', 'C19.A93', 'C19.A94', 'C19.A95', 'C19.A96', 'C19.A97', 'C19.P01', 'C19.P02', 'C19.P05', 'C54.002', 'C54.003', 'C54.004', 'C54.005', 'C64.001', 'C64.002', 'C64.003', 'C64.004', 'C64.006', 'C65.001', 'C65.002', 'C67.001', 'C78.001', 'C78.002', 'C78.003', 'C85.001', 'C85.003', 'C85.004', 'C85.005', 'C85.007', 'C85.008', 'C85.009', 'C85.P01', 'C86.001', 'C86.002', 'C86.004', 'C86.005', 'C98.001', 'C13.002', 'C13.004', 'C13.005', 'C13.P01', 'C14.001', 'C14.003', 'C14.004', 'C14.005', 'C14.006', 'C14.007', 'C14.008', 'C14.009', 'C14.010', 'C14.011', 'C14.018', 'C14.026', 'C14.028', 'C14.029', 'C14.971', 'C14.976', 'C14.A09', 'C14.P01', 'C14.P02', 'C50.002', 'C50.P01', 'C48.002', 'C48.003', 'C48.004', 'C48.007', 'C48.008', 'C48.009', 'C48.011', 'C48.012', 'C15.010', 'C15.011', 'C97.001', 'C97.002', 'I100.001', 'I100.002', 'I103.001', 'I103.UPW', 'M01.001', 'M01.003', 'M01.004', 'M01.010', 'M01.011', 'M01.018', 'M01.022', 'M01.024', 'M01.026', 'M01.028', 'M01.972', 'M02.001', 'M02.004', 'M02.006', 'M02.972', 'M03.001', 'M03.002', 'M03.006', 'M03.971', 'M08.003', 'M08.005', 'M10.001', 'M10.002', 'M10.003', 'M10.004', 'M10.005', 'M10.006', 'M10.007', 'M10.008', 'M10.009', 'M10.013', 'M10.014', 'M10.015', 'M10.016', 'M10.017', 'M10.019', 'M10.021', 'M10.022', 'M10.023', 'M10.024', 'M10.026', 'M10.027', 'M10.029', 'M10.030', 'M10.950', 'M10.971', 'M10.973', 'M100.001', 'M12.002', 'M12.004', 'M12.005', 'M12.016', 'M12.018', 'M12.021', 'M12.024', 'M12.025', 'M12.026', 'M12.027', 'M12.028', 'M12.029', 'M12.208', 'M12.209', 'M12.210', 'M12.212', 'M12.214', 'M12.215', 'M12.217', 'M12.218', 'M12.219', 'M12.220', 'M12.221', 'M12.222', 'M12.224', 'M12.225', 'M12.226', 'M12.230', 'M12.231', 'M12.232', 'M12.234', 'M12.235', 'M12.237', 'M12.241', 'M12.244', 'M12.245', 'M12.246', 'M12.301', 'M12.950', 'M12.956', 'M12.957', 'M12.960', 'M12.962', 'M12.963', 'M12.964', 'M12.975', 'M12.976', 'M12.978', 'M12.979', 'M12.981', 'M12.983', 'M12.987', 'M12.990', 'M12.996', 'M12.P01', 'M12.P02', 'M12.P03', 'M13.001', 'M13.002', 'M13.003', 'M13.007', 'M13.008', 'M13.090', 'M13.091', 'M41.006', 'M41.007', 'M41.016', 'M41.026', 'M41.A19', 'M43.004', 'M43.005', 'M48.003', 'M48.017', 'M49.001', 'M49.972', 'M49.P01', 'M54.002', 'M54.003', 'M76.001', 'M87.001', 'M87.002', 'M87.003', 'M98.A03', 'M14.001', 'M14.002', 'M14.003', 'M14.004', 'M14.005', 'M14.006', 'M14.009', 'M14.010', 'M14.011', 'M14.012', 'M14.016', 'M14.017', 'M14.018', 'M14.020', 'M14.021', 'M14.025', 'M14.026', 'M14.027', 'M14.028', 'M14.029', 'M14.030', 'M14.039', 'M14.950', 'M14.951', 'M14.955', 'M16.002', 'M16.005', 'M16.009', 'M16.971', 'M16.973', 'M16.974', 'M16.981', 'M16.982', 'M16.983', 'M16.984', 'M16.987', 'M16.P01', 'M17.001', 'M17.005', 'M17.006', 'M24.002', 'M24.005', 'M24.007', 'M24.009', 'M24.017', 'M24.026', 'M24.028', 'M24.950', 'M24.973', 'M24.974', 'M24.975', 'M24.976', 'M24.977', 'M18.002', 'M20.005', 'M20.006', 'M20.011', 'M20.021', 'M20.973', 'M28.010', 'M28.011', 'M28.012', 'M28.014', 'M28.016', 'M28.018', 'M28.972', 'M28.973', 'M28.974', 'M28.975', 'M28.978', 'M19.001', 'M19.002', 'M19.004', 'M38.972', 'M38.973', 'M38.974', 'M38.975', 'M38.976', 'M38.977', 'M38.978', 'M38.979', 'M38.980', 'M38.981', 'M50.001', 'M67.002', 'M67.003', 'M67.004', 'M67.005', 'M67.006', 'M67.008', 'M67.011', 'M67.971', 'M67.972', 'M67.973', 'M67.974', 'M67.975', 'M67.A10', 'S01.010', 'S01.011', 'S01.015', 'S01.017', 'S01.019', 'S01.020', 'S01.021', 'S01.028', 'S01.029', 'S01.033', 'S01.034', 'S01.047', 'S01.054', 'S01.072', 'S01.074', 'S01.075', 'S01.078', 'S01.079', 'S01.081', 'S01.085', 'S01.087', 'S01.088', 'S01.105', 'S01.127', 'S01.131', 'S01.132', 'S01.133', 'S01.134', 'S01.135', 'S01.139', 'S01.140', 'S01.143', 'S01.146', 'S01.147', 'S01.152', 'S01.153', 'S01.154', 'S01.155', 'S01.156', 'S01.157', 'S01.159', 'S01.160', 'S01.161', 'S01.162', 'S01.174', 'S01.189', 'S01.191', 'S01.192', 'S01.193', 'S01.194', 'S01.196', 'S01.198', 'S01.199', 'S01.205', 'S01.206', 'S01.211', 'S01.212', 'S01.213', 'S01.214', 'S01.215', 'S01.216', 'S01.217', 'S01.218', 'S01.223', 'S01.224', 'S01.228', 'S01.229', 'S01.231', 'S01.232', 'S01.233', 'S01.236', 'S01.237', 'S01.244', 'S01.246', 'S01.247', 'S01.251', 'S01.252', 'S01.256', 'S01.257', 'S01.258', 'S01.277', 'S01.278', 'S01.284', 'S01.285', 'S01.286', 'S01.291', 'S01.292', 'S01.298', 'S01.299', 'S01.300', 'S01.302', 'S01.306', 'S01.307', 'S01.308', 'S01.309', 'S01.311', 'S01.313', 'S01.318', 'S01.319', 'S01.320', 'S01.321', 'S01.322', 'S01.325', 'S01.326', 'S01.327', 'S01.362', 'S01.365', 'S01.374', 'S01.375', 'S01.376', 'S01.394', 'S01.395', 'S01.414', 'S01.436', 'S01.487', 'S01.488', 'S01.514', 'S01.530', 'S01.531', 'S01.933', 'S01.934', 'S01.940', 'S01.941', 'S01.957', 'S01.969', 'S01.971', 'S01.972', 'S01.974', 'S01.975', 'S01.976', 'S01.979', 'S01.985', 'S01.989', 'S01.992', 'S01.993', 'S01.994', 'S01.998', 'S01.999', 'S01.B93', 'S01.P08', 'S01.P09', 'S01.P10', 'S01.P11', 'S01.P19', 'C44.001', 'C44.970', 'C44.972', 'C44.973', 'C44.974', 'C69.003', 'C69.004', 'C69.005', 'C89.001', 'C89.002', 'C95.001', 'P02.001', 'P02.002', 'P02.003', 'P02.005', 'P02.006', 'P02.007', 'P02.008', 'P02.009', 'P02.010', 'P02.011', 'P02.013', 'P02.014', 'P02.015', 'P02.016', 'P02.017', 'P02.018', 'P02.019', 'P02.020', 'P02.021', 'P02.022', 'P02.023', 'P02.024', 'P02.025', 'P02.026', 'P02.027', 'P02.028', 'P02.029', 'P02.036', 'P02.038', 'P02.039', 'P02.041', 'P02.042', 'T01.010', 'T01.011', 'T01.012', 'T01.013', 'T01.014', 'T01.015', 'T01.016', 'T01.017', 'T01.020', 'T01.971', 'T01.972', 'T01.973', 'T01.974', 'T01.975', 'T01.976', 'T01.977', 'T01.978', 'T01.983', 'T01.984', 'T01.986', 'T01.987', 'T01.991', 'T01.P02', 'T01.P03', 'T02.001', 'T02.002', 'T02.004', 'T03.002', 'T03.006', 'T03.015', 'T03.016', 'T03.017', 'T03.018', 'T03.019', 'T03.021', 'T03.024', 'T03.971', 'C26.001', 'C26.950', 'C26.951', 'C26.952', 'C26.964', 'C26.966', 'C26.A36', 'C56.002', 'C56.003', 'C56.971', 'C56.972', 'C56.974', 'C56.975', 'C46.002', 'C46.003', 'C46.004', 'S68.001', 'S68.002', 'S71.001', 'S71.002', 'S72.001', 'S79.001', 'S79.002', 'S08.039', 'S08.063', 'S08.071', 'S08.072', 'S08.073', 'S08.074', 'S08.075', 'S08.076', 'S08.077', 'S08.A56', 'S53.003', 'S09.001', 'S09.003', 'S09.004', 'S09.007', 'S09.015', 'S09.018', 'S09.019', 'S09.025', 'S09.027', 'S09.051', 'S09.052', 'S09.053', 'S09.055', 'S09.061', 'S09.062', 'S09.065', 'S09.068', 'S09.939', 'S09.941', 'S09.942', 'S09.943', 'S09.944', 'S09.958', 'S09.959', 'S09.960', 'S09.973', 'S09.974', 'S09.977', 'S09.978', 'S09.979', 'S09.980', 'S09.981', 'S09.982', 'S09.984', 'S09.985', 'S09.986', 'S09.987', 'S09.988', 'S09.989', 'S09.990', 'S09.991', 'S09.992', 'S09.993', 'S09.994', 'S09.995', 'S09.A49', 'S09.A50', 'S09.B13', 'S10.002', 'S10.003', 'S10.013', 'S28.001', 'S28.002', 'S28.003', 'S33.011', 'S33.012', 'S33.013', 'S33.017', 'S33.018', 'S33.019', 'S33.020', 'S33.971', 'S33.972', 'S33.973', 'S33.974', 'S33.975', 'S33.976', 'S33.978', 'S33.979', 'S33.981', 'S33.982', 'S33.983', 'S33.984', 'S33.986', 'S33.987', 'S33.988', 'S33.989', 'S33.997', 'S12.004', 'S12.012', 'S26.002', 'S26.009', 'S26.010', 'S26.022', 'S26.A09', 'S21.A01', 'S16.002', 'S16.006', 'S14.003', 'S41.950', 'S41.951', 'S41.956', 'S74.003', 'S59.001', 'S59.951', 'S60.001', 'S60.970', 'S60.972', 'S60.973', 'S60.974', 'S60.975', 'S60.976', 'S60.977', 'S54.002', 'S54.005', 'S54.006', 'S54.008', 'S54.009', 'S54.951', 'S54.952', 'S54.953', 'S54.955']
merops_code_mece.
['A01.001', 'A01.003', 'A01.004', 'A01.007', 'A01.009', 'A01.010', 'A01.041', 'A01.046', 'A01.057', 'A01.070', 'A01.071', 'A01.083', 'A01.A96', 'A01.P01', 'A01.P02', 'A02.010', 'A02.011', 'A02.019', 'A02.024', 'A02.053', 'A02.055', 'A02.056', 'A02.057', 'A02.P01', 'A02.P02', 'A02.P03', 'A02.P04', 'A02.P05', 'A02.P06', 'A02.P07', 'A02.P08', 'A02.P09', 'A02.P10', 'A02.P11', 'A02.P12', 'A02.P13', 'A02.P14', 'A02.P15', 'A02.P16', 'A02.P17', 'A02.P18', 'A02.P19', 'A02.P20', 'non-peptidase homologue', 'unassigned', 'A28.001', 'A28.002', 'A28.003', 'A28.004', 'A28.A10', 'A22.001', 'A22.002', 'A22.003', 'A22.004', 'A22.005', 'A22.006', 'A22.007', 'A22.P01', 'A22.P02', 'C01.009', 'C01.013', 'C01.018', 'C01.032', 'C01.034', 'C01.035', 'C01.036', 'C01.037', 'C01.040', 'C01.060', 'C01.070', 'C01.084', 'C01.973', 'C01.975', 'C01.P02', 'C01.P03', 'C01.P04', 'C01.P07', 'C01.P08', 'C02.001', 'C02.002', 'C02.004', 'C02.006', 'C02.007', 'C02.011', 'C02.013', 'C02.017', 'C02.018', 'C02.020', 'C02.021', 'C02.029', 'C02.031', 'C02.971', 'C02.972', 'C101.001', 'C101.950', 'C110.001', 'C111.001', 'C111.002', 'C111.003', 'C111.004', 'C111.005', 'C111.006', 'C111.007', 'C111.008', 'C111.009', 'C111.950', 'C115.001', 'C115.002', 'C12.001', 'C12.003', 'C12.004', 'C12.005', 'C121.001', 'C121.002', 'C19.001', 'C19.009', 'C19.010', 'C19.011', 'C19.012', 'C19.013', 'C19.014', 'C19.015', 'C19.016', 'C19.017', 'C19.018', 'C19.019', 'C19.020', 'C19.021', 'C19.022', 'C19.023', 'C19.024', 'C19.025', 'C19.026', 'C19.028', 'C19.030', 'C19.034', 'C19.035', 'C19.037', 'C19.040', 'C19.041', 'C19.042', 'C19.044', 'C19.046', 'C19.047', 'C19.048', 'C19.052', 'C19.053', 'C19.054', 'C19.055', 'C19.056', 'C19.057', 'C19.058', 'C19.059', 'C19.060', 'C19.064', 'C19.065', 'C19.067', 'C19.068', 'C19.069', 'C19.070', 'C19.071', 'C19.072', 'C19.073', 'C19.078', 'C19.080', 'C19.081', 'C19.106', 'C19.107', 'C19.108', 'C19.972', 'C19.974', 'C19.978', 'C19.984', 'C19.985', 'C19.986', 'C19.987', 'C19.A82', 'C19.A83', 'C19.A84', 'C19.A85', 'C19.A86', 'C19.A87', 'C19.A88', 'C19.A89', 'C19.A90', 'C19.A91', 'C19.A92', 'C19.A93', 'C19.A94', 'C19.A95', 'C19.A96', 'C19.A97', 'C19.P01', 'C19.P02', 'C19.P05', 'C54.002', 'C54.003', 'C54.004', 'C54.005', 'C64.001', 'C64.002', 'C64.003', 'C64.004', 'C64.006', 'C65.001', 'C65.002', 'C67.001', 'C78.001', 'C78.002', 'C78.003', 'C85.001', 'C85.003', 'C85.004', 'C85.005', 'C85.007', 'C85.008', 'C85.009', 'C85.P01', 'C86.001', 'C86.002', 'C86.004', 'C86.005', 'C98.001', 'C13.002', 'C13.004', 'C13.005', 'C13.P01', 'C14.001', 'C14.003', 'C14.004', 'C14.005', 'C14.006', 'C14.007', 'C14.008', 'C14.009', 'C14.010', 'C14.011', 'C14.018', 'C14.026', 'C14.028', 'C14.029', 'C14.971', 'C14.976', 'C14.A09', 'C14.P01', 'C14.P02', 'C50.002', 'C50.P01', 'C48.002', 'C48.003', 'C48.004', 'C48.007', 'C48.008', 'C48.009', 'C48.011', 'C48.012', 'C15.010', 'C15.011', 'C97.001', 'C97.002', 'I100.001', 'I100.002', 'I103.001', 'I103.UPW', 'M01.001', 'M01.003', 'M01.004', 'M01.010', 'M01.011', 'M01.018', 'M01.022', 'M01.024', 'M01.026', 'M01.028', 'M01.972', 'M02.001', 'M02.004', 'M02.006', 'M02.972', 'M03.001', 'M03.002', 'M03.006', 'M03.971', 'M08.003', 'M08.005', 'M10.001', 'M10.002', 'M10.003', 'M10.004', 'M10.005', 'M10.006', 'M10.007', 'M10.008', 'M10.009', 'M10.013', 'M10.014', 'M10.015', 'M10.016', 'M10.017', 'M10.019', 'M10.021', 'M10.022', 'M10.023', 'M10.024', 'M10.026', 'M10.027', 'M10.029', 'M10.030', 'M10.950', 'M10.971', 'M10.973', 'M100.001', 'M12.002', 'M12.004', 'M12.005', 'M12.016', 'M12.018', 'M12.021', 'M12.024', 'M12.025', 'M12.026', 'M12.027', 'M12.028', 'M12.029', 'M12.208', 'M12.209', 'M12.210', 'M12.212', 'M12.214', 'M12.215', 'M12.217', 'M12.218', 'M12.219', 'M12.220', 'M12.221', 'M12.222', 'M12.224', 'M12.225', 'M12.226', 'M12.230', 'M12.231', 'M12.232', 'M12.234', 'M12.235', 'M12.237', 'M12.241', 'M12.244', 'M12.245', 'M12.246', 'M12.301', 'M12.950', 'M12.956', 'M12.957', 'M12.960', 'M12.962', 'M12.963', 'M12.964', 'M12.975', 'M12.976', 'M12.978', 'M12.979', 'M12.981', 'M12.983', 'M12.987', 'M12.990', 'M12.996', 'M12.P01', 'M12.P02', 'M12.P03', 'M13.001', 'M13.002', 'M13.003', 'M13.007', 'M13.008', 'M13.090', 'M13.091', 'M41.006', 'M41.007', 'M41.016', 'M41.026', 'M41.A19', 'M43.004', 'M43.005', 'M48.003', 'M48.017', 'M49.001', 'M49.972', 'M49.P01', 'M54.002', 'M54.003', 'M76.001', 'M87.001', 'M87.002', 'M87.003', 'M98.A03', 'M14.001', 'M14.002', 'M14.003', 'M14.004', 'M14.005', 'M14.006', 'M14.009', 'M14.010', 'M14.011', 'M14.012', 'M14.016', 'M14.017', 'M14.018', 'M14.020', 'M14.021', 'M14.025', 'M14.026', 'M14.027', 'M14.028', 'M14.029', 'M14.030', 'M14.039', 'M14.950', 'M14.951', 'M14.955', 'M16.002', 'M16.005', 'M16.009', 'M16.971', 'M16.973', 'M16.974', 'M16.981', 'M16.982', 'M16.983', 'M16.984', 'M16.987', 'M16.P01', 'M17.001', 'M17.005', 'M17.006', 'M24.002', 'M24.005', 'M24.007', 'M24.009', 'M24.017', 'M24.026', 'M24.028', 'M24.950', 'M24.973', 'M24.974', 'M24.975', 'M24.976', 'M24.977', 'M18.002', 'M20.005', 'M20.006', 'M20.011', 'M20.021', 'M20.973', 'M28.010', 'M28.011', 'M28.012', 'M28.014', 'M28.016', 'M28.018', 'M28.972', 'M28.973', 'M28.974', 'M28.975', 'M28.978', 'M19.001', 'M19.002', 'M19.004', 'M38.972', 'M38.973', 'M38.974', 'M38.975', 'M38.976', 'M38.977', 'M38.978', 'M38.979', 'M38.980', 'M38.981', 'M50.001', 'M67.002', 'M67.003', 'M67.004', 'M67.005', 'M67.006', 'M67.008', 'M67.011', 'M67.971', 'M67.972', 'M67.973', 'M67.974', 'M67.975', 'M67.A10', 'S01.010', 'S01.011', 'S01.015', 'S01.017', 'S01.019', 'S01.020', 'S01.021', 'S01.028', 'S01.029', 'S01.033', 'S01.034', 'S01.047', 'S01.054', 'S01.072', 'S01.074', 'S01.075', 'S01.078', 'S01.079', 'S01.081', 'S01.085', 'S01.087', 'S01.088', 'S01.105', 'S01.127', 'S01.131', 'S01.132', 'S01.133', 'S01.134', 'S01.135', 'S01.139', 'S01.140', 'S01.143', 'S01.146', 'S01.147', 'S01.152', 'S01.153', 'S01.154', 'S01.155', 'S01.156', 'S01.157', 'S01.159', 'S01.160', 'S01.161', 'S01.162', 'S01.174', 'S01.189', 'S01.191', 'S01.192', 'S01.193', 'S01.194', 'S01.196', 'S01.198', 'S01.199', 'S01.205', 'S01.206', 'S01.211', 'S01.212', 'S01.213', 'S01.214', 'S01.215', 'S01.216', 'S01.217', 'S01.218', 'S01.223', 'S01.224', 'S01.228', 'S01.229', 'S01.231', 'S01.232', 'S01.233', 'S01.236', 'S01.237', 'S01.244', 'S01.246', 'S01.247', 'S01.251', 'S01.252', 'S01.256', 'S01.257', 'S01.258', 'S01.277', 'S01.278', 'S01.284', 'S01.285', 'S01.286', 'S01.291', 'S01.292', 'S01.298', 'S01.299', 'S01.300', 'S01.302', 'S01.306', 'S01.307', 'S01.308', 'S01.309', 'S01.311', 'S01.313', 'S01.318', 'S01.319', 'S01.320', 'S01.321', 'S01.322', 'S01.325', 'S01.326', 'S01.327', 'S01.362', 'S01.365', 'S01.374', 'S01.375', 'S01.376', 'S01.394', 'S01.395', 'S01.414', 'S01.436', 'S01.487', 'S01.488', 'S01.514', 'S01.530', 'S01.531', 'S01.933', 'S01.934', 'S01.940', 'S01.941', 'S01.957', 'S01.969', 'S01.971', 'S01.972', 'S01.974', 'S01.975', 'S01.976', 'S01.979', 'S01.985', 'S01.989', 'S01.992', 'S01.993', 'S01.994', 'S01.998', 'S01.999', 'S01.B93', 'S01.P08', 'S01.P09', 'S01.P10', 'S01.P11', 'S01.P19', 'C44.001', 'C44.970', 'C44.972', 'C44.973', 'C44.974', 'C69.003', 'C69.004', 'C69.005', 'C89.001', 'C89.002', 'C95.001', 'P02.001', 'P02.002', 'P02.003', 'P02.005', 'P02.006', 'P02.007', 'P02.008', 'P02.009', 'P02.010', 'P02.011', 'P02.013', 'P02.014', 'P02.015', 'P02.016', 'P02.017', 'P02.018', 'P02.019', 'P02.020', 'P02.021', 'P02.022', 'P02.023', 'P02.024', 'P02.025', 'P02.026', 'P02.027', 'P02.028', 'P02.029', 'P02.036', 'P02.038', 'P02.039', 'P02.041', 'P02.042', 'T01.010', 'T01.011', 'T01.012', 'T01.013', 'T01.014', 'T01.015', 'T01.016', 'T01.017', 'T01.020', 'T01.971', 'T01.972', 'T01.973', 'T01.974', 'T01.975', 'T01.976', 'T01.977', 'T01.978', 'T01.983', 'T01.984', 'T01.986', 'T01.987', 'T01.991', 'T01.P02', 'T01.P03', 'T02.001', 'T02.002', 'T02.004', 'T03.002', 'T03.006', 'T03.015', 'T03.016', 'T03.017', 'T03.018', 'T03.019', 'T03.021', 'T03.024', 'T03.971', 'C26.001', 'C26.950', 'C26.951', 'C26.952', 'C26.964', 'C26.966', 'C26.A36', 'C56.002', 'C56.003', 'C56.971', 'C56.972', 'C56.974', 'C56.975', 'C46.002', 'C46.003', 'C46.004', 'S68.001', 'S68.002', 'S71.001', 'S71.002', 'S72.001', 'S79.001', 'S79.002', 'S08.039', 'S08.063', 'S08.071', 'S08.072', 'S08.073', 'S08.074', 'S08.075', 'S08.076', 'S08.077', 'S08.A56', 'S53.003', 'S09.001', 'S09.003', 'S09.004', 'S09.007', 'S09.015', 'S09.018', 'S09.019', 'S09.025', 'S09.027', 'S09.051', 'S09.052', 'S09.053', 'S09.055', 'S09.061', 'S09.062', 'S09.065', 'S09.068', 'S09.939', 'S09.941', 'S09.942', 'S09.943', 'S09.944', 'S09.958', 'S09.959', 'S09.960', 'S09.973', 'S09.974', 'S09.977', 'S09.978', 'S09.979', 'S09.980', 'S09.981', 'S09.982', 'S09.984', 'S09.985', 'S09.986', 'S09.987', 'S09.988', 'S09.989', 'S09.990', 'S09.991', 'S09.992', 'S09.993', 'S09.994', 'S09.995', 'S09.A49', 'S09.A50', 'S09.B13', 'S10.002', 'S10.003', 'S10.013', 'S28.001', 'S28.002', 'S28.003', 'S33.011', 'S33.012', 'S33.013', 'S33.017', 'S33.018', 'S33.019', 'S33.020', 'S33.971', 'S33.972', 'S33.973', 'S33.974', 'S33.975', 'S33.976', 'S33.978', 'S33.979', 'S33.981', 'S33.982', 'S33.983', 'S33.984', 'S33.986', 'S33.987', 'S33.988', 'S33.989', 'S33.997', 'S12.004', 'S12.012', 'S26.002', 'S26.009', 'S26.010', 'S26.022', 'S26.A09', 'S21.A01', 'S16.002', 'S16.006', 'S14.003', 'S41.950', 'S41.951', 'S41.956', 'S74.003', 'S59.001', 'S59.951', 'S60.001', 'S60.970', 'S60.972', 'S60.973', 'S60.974', 'S60.975', 'S60.976', 'S60.977', 'S54.002', 'S54.005', 'S54.006', 'S54.008', 'S54.009', 'S54.951', 'S54.952', 'S54.953', 'S54.955']
862
subs_count_list.
[]
==================================protease741=======================================
protease.
S08.071
protease_turn.
741
df_cleave_pattern.
Empty DataFrame
Columns: [protease_turn, merops_id, substrate_turn, uniprot_id, p1, len_full_aa, cleave_pattern, full_aa]
Index: []
df_negative_pattern.
Empty DataFrame
Columns: [protease_turn, merops_id, substrate_turn, uniprot_id, p1, negative_pattern, full_aa, len_full_aa, start, end, a[k]]
Index: []
this is ok.
merops_code:S08.071
subs.
(('B2RXX5', 236), ('C8UEJ9', 273), ('O00292', 77), ('O08665', 555), ('O14672', 213), ('O15072', 249), ('O43184', 207), ('O43508-2', 184), ('O43915', 88), ('O43915', 99), ('O43915', 205), ('O54732', 127), ('O56140', 346), ('O56861', 127), ('O60494', 35), ('O75173', 209), ('O75173', 212), ('O75829', 214), ('O88839', 207), ('O95450', 88), ('O95450', 255), ('O95450', 259), ('P00587', 218), ('P00588', 225), ('P00740', 46), ('P01026', 670), ('P01127', 81), ('P01137', 278), ('P01138', 121), ('P01139', 121), ('P01189', 155), ('P01189', 178), ('P01189', 236), ('P01210', 142), ('P01210', 195), ('P01210', 236), ('P01270', 31), ('P01298', 68), ('P01343', 119), ('P01344', 92), ('P01350', 58), ('P02768', 24), ('P02770', 24), ('P03107', 12), ('P03188', 432), ('P03316', 328), ('P03459', 342), ('P04070', 42), ('P04070', 199), ('P04085', 86), ('P04275', 763), ('P04578', 511), ('P05019', 119), ('P05305', 52), ('P05305', 92), ('P05305', 108), ('P05305', 168), ('P05408', 181), ('P06213', 762), ('P06300', 234), ('P06756', 890), ('P06828', 109), ('P08253', 101), ('P08294', 231), ('P08581', 307), ('P08648', 894), ('P09167', 455), ('P09958', 70), ('P09958', 75), ('P09958', 104), ('P09958', 107), ('P10163', 240), ('P11132', 344), ('P11223', 537), ('P11439', 304), ('P12272', 36), ('P12644', 292), ('P12961', 181), ('P13201', 460), ('P13423', 196), ('P13497', 120), ('P13612', 591), ('P14200', 146), ('P16860', 102), ('P20783', 138), ('P21754', 352), ('P23188', 70), ('P23188', 104), ('P23188', 107), ('P23229', 941), ('P23377', 70), ('P23377', 104), ('P23560', 128), ('P24347', 97), ('P26006', 875), ('P29119', 105), ('P29788', 399), ('P29990', 205), ('P30885', 252), ('P30885', 287), ('P32926', 49), ('P34130', 80), ('P35555', 2731), ('P35822', 643), ('P43026', 380), ('P43026', 381), ('P49000', 445), ('P49767', 227), ('P50281', 111), ('P51512', 116), ('P56817', 45), ('P56818', 45), ('P58397', 82), ('P58397', 240), ('P58459', 66), ('P58459', 96), ('P58459', 233), ('P69353', 112), ('P78325', 200), ('P97857', 251), ('Q01705', 1654), ('Q02413', 49), ('Q05320', 501), ('Q07456', 204), ('Q07954', 3943), ('Q13275', 779), ('Q13444', 206), ('Q13683', 958), ('Q14563', 555), ('Q16819', 653), ('Q16962', 95), ('Q28193', 70), ('Q28193', 104), ('Q28193', 107), ('Q3U435', 162), ('Q4ZG58', 832), ('Q53XC5', 256), ('Q60813', 220), ('Q61180', 205), ('Q61180', 231), ('Q68SA9', 58), ('Q68SA9', 60), ('Q68SA9', 220), ('Q6SW76', 460), ('Q76LX8', 74), ('Q7K8Y3', 342), ('Q80YP5', 898), ('Q84193', 109), ('Q8BMF8', 94), ('Q8GI68', 398), ('Q8K4G2', 99), ('Q8N119', 144), ('Q8NBP7', 218), ('Q8NFH7', 104), ('Q8V1Q2', 116), ('Q8WXS8', 249), ('Q91000', 108), ('Q92673', 81), ('Q92838', 159), ('Q99075', 62), ('Q9FBI2', 273), ('Q9GZP0', 257), ('Q9GZV9', 179), ('Q9H013', 203), ('Q9H324', 66), ('Q9H324', 96), ('Q9H324', 233), ('Q9NDH6', 218), ('Q9NPA2', 107), ('Q9NRA1', 234), ('Q9P2N4', 287), ('Q9QY05', 165), ('Q9R001', 230), ('Q9R001', 260), ('Q9R001', 261), ('Q9R1Q9', 225), ('Q9UHI8', 252), ('Q9UKP4', 68), ('Q9UKP4', 70), ('Q9UKP4', 92), ('Q9UKP4', 218), ('Q9UKP4', 229), ('Q9UKP4', 232), ('Q9UKP4', 236), ('Q9UKP5', 71), ('Q9UKP5', 244), ('Q9WMU9', 466), ('Q9WU39', 143), ('Q9Y1A6', 104), ('Q9Y275', 133), ('Q9Y287', 243), ('Q9Y5R2', 155), ('Q9Y5X9', 330))
sub.
('B2RXX5', 236)
sub.
('C8UEJ9', 273)
sub.
('O00292', 77)
sub.
('O08665', 555)
sub.
('O14672', 213)
sub.
('O15072', 249)
sub.
('O43184', 207)
sub.
('O43508-2', 184)
sub.
('O43915', 88)
sub.
('O43915', 99)
sub.
('O43915', 205)
sub.
('O54732', 127)
sub.
('O56140', 346)
sub.
('O56861', 127)
sub.
('O60494', 35)
sub.
('O75173', 209)
sub.
('O75173', 212)
sub.
('O75829', 214)
sub.
('O88839', 207)
sub.
('O95450', 88)
sub.
('O95450', 255)
sub.
('O95450', 259)
sub.
('P00587', 218)
sub.
('P00588', 225)
sub.
('P00740', 46)
sub.
('P01026', 670)
sub.
('P01127', 81)
sub.
('P01137', 278)
sub.
('P01138', 121)
sub.
('P01139', 121)
sub.
('P01189', 155)
sub.
('P01189', 178)
sub.
('P01189', 236)
sub.
('P01210', 142)
sub.
('P01210', 195)
sub.
('P01210', 236)
sub.
('P01270', 31)
sub.
('P01298', 68)
sub.
('P01343', 119)
sub.
('P01344', 92)
sub.
('P01350', 58)
sub.
('P02768', 24)
sub.
('P02770', 24)
sub.
('P03107', 12)
sub.
('P03188', 432)
sub.
('P03316', 328)
sub.
('P03459', 342)
sub.
('P04070', 42)
sub.
('P04070', 199)
sub.
('P04085', 86)
sub.
('P04275', 763)
sub.
('P04578', 511)
sub.
('P05019', 119)
sub.
('P05305', 52)
sub.
('P05305', 92)
sub.
('P05305', 108)
sub.
('P05305', 168)
sub.
('P05408', 181)
sub.
('P06213', 762)
sub.
('P06300', 234)
sub.
('P06756', 890)
sub.
('P06828', 109)
sub.
('P08253', 101)
sub.
('P08294', 231)
sub.
('P08581', 307)
sub.
('P08648', 894)
sub.
('P09167', 455)
sub.
('P09958', 70)
sub.
('P09958', 75)
sub.
('P09958', 104)
sub.
('P09958', 107)
sub.
('P10163', 240)
sub.
('P11132', 344)
sub.
('P11223', 537)
sub.
('P11439', 304)
sub.
('P12272', 36)
sub.
('P12644', 292)
sub.
('P12961', 181)
sub.
('P13201', 460)
sub.
('P13423', 196)
sub.
('P13497', 120)
sub.
('P13612', 591)
sub.
('P14200', 146)
sub.
('P16860', 102)
sub.
('P20783', 138)
sub.
('P21754', 352)
sub.
('P23188', 70)
sub.
('P23188', 104)
sub.
('P23188', 107)
sub.
('P23229', 941)
sub.
('P23377', 70)
sub.
('P23377', 104)
sub.
('P23560', 128)
sub.
('P24347', 97)
sub.
('P26006', 875)
sub.
('P29119', 105)
sub.
('P29788', 399)
sub.
('P29990', 205)
sub.
('P30885', 252)
sub.
('P30885', 287)
sub.
('P32926', 49)
sub.
('P34130', 80)
sub.
('P35555', 2731)
sub.
('P35822', 643)
sub.
('P43026', 380)
sub.
('P43026', 381)
sub.
('P49000', 445)
sub.
('P49767', 227)
sub.
('P50281', 111)
sub.
('P51512', 116)
sub.
('P56817', 45)
sub.
('P56818', 45)
sub.
('P58397', 82)
sub.
('P58397', 240)
sub.
('P58459', 66)
sub.
('P58459', 96)
sub.
('P58459', 233)
sub.
('P69353', 112)
sub.
('P78325', 200)
sub.
('P97857', 251)
sub.
('Q01705', 1654)
sub.
('Q02413', 49)
sub.
('Q05320', 501)
sub.
('Q07456', 204)
sub.
('Q07954', 3943)
sub.
('Q13275', 779)
sub.
('Q13444', 206)
sub.
('Q13683', 958)
sub.
('Q14563', 555)
sub.
('Q16819', 653)
sub.
('Q16962', 95)
sub.
('Q28193', 70)
sub.
('Q28193', 104)
sub.
('Q28193', 107)
sub.
('Q3U435', 162)
sub.
('Q4ZG58', 832)
sub.
('Q53XC5', 256)
sub.
('Q60813', 220)
sub.
('Q61180', 205)
sub.
('Q61180', 231)
sub.
('Q68SA9', 58)
sub.
('Q68SA9', 60)
sub.
('Q68SA9', 220)
sub.
('Q6SW76', 460)
sub.
('Q76LX8', 74)
sub.
('Q7K8Y3', 342)
sub.
('Q80YP5', 898)
sub.
('Q84193', 109)
sub.
('Q8BMF8', 94)
sub.
('Q8GI68', 398)
sub.
('Q8K4G2', 99)
sub.
('Q8N119', 144)
sub.
('Q8NBP7', 218)
sub.
('Q8NFH7', 104)
sub.
('Q8V1Q2', 116)
sub.
('Q8WXS8', 249)
sub.
('Q91000', 108)
sub.
('Q92673', 81)
sub.
('Q92838', 159)
sub.
('Q99075', 62)
sub.
('Q9FBI2', 273)
sub.
('Q9GZP0', 257)
sub.
('Q9GZV9', 179)
sub.
('Q9H013', 203)
sub.
('Q9H324', 66)
sub.
('Q9H324', 96)
sub.
('Q9H324', 233)
sub.
('Q9NDH6', 218)
sub.
('Q9NPA2', 107)
sub.
('Q9NRA1', 234)
sub.
('Q9P2N4', 287)
sub.
('Q9QY05', 165)
sub.
('Q9R001', 230)
sub.
('Q9R001', 260)
sub.
('Q9R001', 261)
sub.
('Q9R1Q9', 225)
sub.
('Q9UHI8', 252)
sub.
('Q9UKP4', 68)
sub.
('Q9UKP4', 70)
sub.
('Q9UKP4', 92)
sub.
('Q9UKP4', 218)
sub.
('Q9UKP4', 229)
sub.
('Q9UKP4', 232)
sub.
('Q9UKP4', 236)
sub.
('Q9UKP5', 71)
sub.
('Q9UKP5', 244)
sub.
('Q9WMU9', 466)
sub.
('Q9WU39', 143)
sub.
('Q9Y1A6', 104)
sub.
('Q9Y275', 133)
sub.
('Q9Y287', 243)
sub.
('Q9Y5R2', 155)
sub.
('Q9Y5X9', 330)
subs.
193
list_subs:
(('B2RXX5', 236), ('C8UEJ9', 273), ('O00292', 77), ('O08665', 555), ('O14672', 213), ('O15072', 249), ('O43184', 207), ('O43508-2', 184), ('O43915', 88), ('O43915', 99), ('O43915', 205), ('O54732', 127), ('O56140', 346), ('O56861', 127), ('O60494', 35), ('O75173', 209), ('O75173', 212), ('O75829', 214), ('O88839', 207), ('O95450', 88), ('O95450', 255), ('O95450', 259), ('P00587', 218), ('P00588', 225), ('P00740', 46), ('P01026', 670), ('P01127', 81), ('P01137', 278), ('P01138', 121), ('P01139', 121), ('P01189', 155), ('P01189', 178), ('P01189', 236), ('P01210', 142), ('P01210', 195), ('P01210', 236), ('P01270', 31), ('P01298', 68), ('P01343', 119), ('P01344', 92), ('P01350', 58), ('P02768', 24), ('P02770', 24), ('P03107', 12), ('P03188', 432), ('P03316', 328), ('P03459', 342), ('P04070', 42), ('P04070', 199), ('P04085', 86), ('P04275', 763), ('P04578', 511), ('P05019', 119), ('P05305', 52), ('P05305', 92), ('P05305', 108), ('P05305', 168), ('P05408', 181), ('P06213', 762), ('P06300', 234), ('P06756', 890), ('P06828', 109), ('P08253', 101), ('P08294', 231), ('P08581', 307), ('P08648', 894), ('P09167', 455), ('P09958', 70), ('P09958', 75), ('P09958', 104), ('P09958', 107), ('P10163', 240), ('P11132', 344), ('P11223', 537), ('P11439', 304), ('P12272', 36), ('P12644', 292), ('P12961', 181), ('P13201', 460), ('P13423', 196), ('P13497', 120), ('P13612', 591), ('P14200', 146), ('P16860', 102), ('P20783', 138), ('P21754', 352), ('P23188', 70), ('P23188', 104), ('P23188', 107), ('P23229', 941), ('P23377', 70), ('P23377', 104), ('P23560', 128), ('P24347', 97), ('P26006', 875), ('P29119', 105), ('P29788', 399), ('P29990', 205), ('P30885', 252), ('P30885', 287), ('P32926', 49), ('P34130', 80), ('P35555', 2731), ('P35822', 643), ('P43026', 380), ('P43026', 381), ('P49000', 445), ('P49767', 227), ('P50281', 111), ('P51512', 116), ('P56817', 45), ('P56818', 45), ('P58397', 82), ('P58397', 240), ('P58459', 66), ('P58459', 96), ('P58459', 233), ('P69353', 112), ('P78325', 200), ('P97857', 251), ('Q01705', 1654), ('Q02413', 49), ('Q05320', 501), ('Q07456', 204), ('Q07954', 3943), ('Q13275', 779), ('Q13444', 206), ('Q13683', 958), ('Q14563', 555), ('Q16819', 653), ('Q16962', 95), ('Q28193', 70), ('Q28193', 104), ('Q28193', 107), ('Q3U435', 162), ('Q4ZG58', 832), ('Q53XC5', 256), ('Q60813', 220), ('Q61180', 205), ('Q61180', 231), ('Q68SA9', 58), ('Q68SA9', 60), ('Q68SA9', 220), ('Q6SW76', 460), ('Q76LX8', 74), ('Q7K8Y3', 342), ('Q80YP5', 898), ('Q84193', 109), ('Q8BMF8', 94), ('Q8GI68', 398), ('Q8K4G2', 99), ('Q8N119', 144), ('Q8NBP7', 218), ('Q8NFH7', 104), ('Q8V1Q2', 116), ('Q8WXS8', 249), ('Q91000', 108), ('Q92673', 81), ('Q92838', 159), ('Q99075', 62), ('Q9FBI2', 273), ('Q9GZP0', 257), ('Q9GZV9', 179), ('Q9H013', 203), ('Q9H324', 66), ('Q9H324', 96), ('Q9H324', 233), ('Q9NDH6', 218), ('Q9NPA2', 107), ('Q9NRA1', 234), ('Q9P2N4', 287), ('Q9QY05', 165), ('Q9R001', 230), ('Q9R001', 260), ('Q9R001', 261), ('Q9R1Q9', 225), ('Q9UHI8', 252), ('Q9UKP4', 68), ('Q9UKP4', 70), ('Q9UKP4', 92), ('Q9UKP4', 218), ('Q9UKP4', 229), ('Q9UKP4', 232), ('Q9UKP4', 236), ('Q9UKP5', 71), ('Q9UKP5', 244), ('Q9WMU9', 466), ('Q9WU39', 143), ('Q9Y1A6', 104), ('Q9Y275', 133), ('Q9Y287', 243), ('Q9Y5R2', 155), ('Q9Y5X9', 330))
----------------------protease: 742, S08.071; positive_data: 1/193, ('B2RXX5', 236)--------------------------
uniprot_id: B2RXX5
result01:
<re.Match object; span=(0, 6), match='B2RXX5'>
result02
<re.Match object; span=(0, 6), match='B2RXX5'>
uniprot_id after re: B2RXX5
result.
<re.Match object; span=(0, 6), match='B2RXX5'>
p1: 236
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:99: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['uniprotKB_accession'][0] = uid
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:99: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  df['uniprotKB_accession'][0] = uid
function was not detected.
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:122: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df["sequence"][0] = sequence.text
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:122: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  df["sequence"][0] = sequence.text
                       uniprotKB_accession function                                           sequence
protease742_substrate0              B2RXX5        1  MAWLRALLHCLLPWYCALCAAAGSQTPDLRLSGKLHDYVVTVPCST...
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:126: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  print(df["sequence"][0])
MAWLRALLHCLLPWYCALCAAAGSQTPDLRLSGKLHDYVVTVPCSTDFQGRFLSHVVSAPAAPSPRSHLRVARSPLSLERETPRPGGPRQHFLYFNVTVFGKLLHLRLQPNRRLVAPGAPVEWQEDFRELFRQPLQQECVYTGGVTGMPGAAVAISNCDGLAGLIRTDNSDYFIEPLERGQQEKEAGGRTHVVYRREAVQREWKEPHGDLHNEAFGLGDLPNVLDLVGDRLGDAERKRRHAKPGSYSIEVLLAVDDSVVRFHGREHTQNYVLTLMNIVDEIYHDESLGAHVNIALVRLIMVGYRQSLSLIERGNPARSLEQVCRWAHSQQRQDPSHTEHHDHVIFLTRQNFGPSGYAPVTGMCHPLRSCALNHEDGFSSAFVVAHETGHVLGMEHDGQGNGCDDETSLGSVMAPLVQAAFHRFHWSRCSKLELSRYLPSYDCLLDDPFERTWPQPPELPGIDYSMDEQCRFDFGTGYHTCLAFRTFEPCKQLWCSHPDNPYFCKTKKGPPLDGTECAPGKWCFKGHCIWKSPEQTYGQDGGWSSWTNFGSCSRSCGGGVRSRSRSCDNPPPAYGGRPCSGSMFEYQICNSEDCPGPYEDFRAQQCAKRNSYYTHQDAKHSWLPYEPDSDAQKCELICQSADTGDVVFMNQVVHDGTRCSYRDPYSVCARGECVPFGCDKEVGSMKTDDKCGVCGGDNSHCRTVKGTLGKGSKQAAALKQVQIPAGARHIQIELLEKAPHRIAVKNQVTGSFIFNPKGKEASSRTFTALGLEWEHEAEDTKDSLRTNGPLPEAIAILVLPPAEGKPRGSLAYKYVIHEDLLPLIGSNNVLLEETDTYEWALKSWSPCSKACGGGIQFTKYGCRRRRDHHMVHRHLCDHKKRPKPIRRRCNQHSCPQPTWVTEEWGACSRSCGKLGLQTRGVQCLLPLSNGTHKAMPAKACLGNRPEAKKPCLRVPCPAQWRTGAWSQCSATCGEGIQQRQVVCRNTSSALGPCEGVKPDMVQICSLPACGGDLQNSTVKAEVQDPVTKTGYREPQSRPLTPEDRISTMEPCVRDRSVFCRMEVLDRYCTIPGYHRLCCESCIKKTSGPNASLALPPTFSTPGSLLPAPKATLEDVKSTRGPTSLEDHRQSQPTQLPDVADRISPVTQYPVTPQMLSPKAFPGNSPATPRRPPQDWTQTAMPTSEGQGQSREEPGHGGTSLPATSPVT
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:127: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  return df["sequence"][0]
full_aa.
MAWLRALLHCLLPWYCALCAAAGSQTPDLRLSGKLHDYVVTVPCSTDFQGRFLSHVVSAPAAPSPRSHLRVARSPLSLERETPRPGGPRQHFLYFNVTVFGKLLHLRLQPNRRLVAPGAPVEWQEDFRELFRQPLQQECVYTGGVTGMPGAAVAISNCDGLAGLIRTDNSDYFIEPLERGQQEKEAGGRTHVVYRREAVQREWKEPHGDLHNEAFGLGDLPNVLDLVGDRLGDAERKRRHAKPGSYSIEVLLAVDDSVVRFHGREHTQNYVLTLMNIVDEIYHDESLGAHVNIALVRLIMVGYRQSLSLIERGNPARSLEQVCRWAHSQQRQDPSHTEHHDHVIFLTRQNFGPSGYAPVTGMCHPLRSCALNHEDGFSSAFVVAHETGHVLGMEHDGQGNGCDDETSLGSVMAPLVQAAFHRFHWSRCSKLELSRYLPSYDCLLDDPFERTWPQPPELPGIDYSMDEQCRFDFGTGYHTCLAFRTFEPCKQLWCSHPDNPYFCKTKKGPPLDGTECAPGKWCFKGHCIWKSPEQTYGQDGGWSSWTNFGSCSRSCGGGVRSRSRSCDNPPPAYGGRPCSGSMFEYQICNSEDCPGPYEDFRAQQCAKRNSYYTHQDAKHSWLPYEPDSDAQKCELICQSADTGDVVFMNQVVHDGTRCSYRDPYSVCARGECVPFGCDKEVGSMKTDDKCGVCGGDNSHCRTVKGTLGKGSKQAAALKQVQIPAGARHIQIELLEKAPHRIAVKNQVTGSFIFNPKGKEASSRTFTALGLEWEHEAEDTKDSLRTNGPLPEAIAILVLPPAEGKPRGSLAYKYVIHEDLLPLIGSNNVLLEETDTYEWALKSWSPCSKACGGGIQFTKYGCRRRRDHHMVHRHLCDHKKRPKPIRRRCNQHSCPQPTWVTEEWGACSRSCGKLGLQTRGVQCLLPLSNGTHKAMPAKACLGNRPEAKKPCLRVPCPAQWRTGAWSQCSATCGEGIQQRQVVCRNTSSALGPCEGVKPDMVQICSLPACGGDLQNSTVKAEVQDPVTKTGYREPQSRPLTPEDRISTMEPCVRDRSVFCRMEVLDRYCTIPGYHRLCCESCIKKTSGPNASLALPPTFSTPGSLLPAPKATLEDVKSTRGPTSLEDHRQSQPTQLPDVADRISPVTQYPVTPQMLSPKAFPGNSPATPRRPPQDWTQTAMPTSEGQGQSREEPGHGGTSLPATSPVT
<class 'str'>
df_cleave_pattern.
   protease_turn  ...                                            full_aa
0            742  ...  MAWLRALLHCLLPWYCALCAAAGSQTPDLRLSGKLHDYVVTVPCST...

[1 rows x 8 columns]
df_cleave_pattern.
   protease_turn  ...                                            full_aa
0            742  ...  MAWLRALLHCLLPWYCALCAAAGSQTPDLRLSGKLHDYVVTVPCST...

[1 rows x 8 columns]
----------------------protease: 742, S08.071; positive_data: 2/193, ('C8UEJ9', 273)--------------------------
uniprot_id: C8UEJ9
result01:
<re.Match object; span=(0, 6), match='C8UEJ9'>
result02
<re.Match object; span=(0, 6), match='C8UEJ9'>
uniprot_id after re: C8UEJ9
result.
<re.Match object; span=(0, 6), match='C8UEJ9'>
p1: 273
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:99: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['uniprotKB_accession'][0] = uid
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:99: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  df['uniprotKB_accession'][0] = uid
function was not detected.
sequence was not detected.
                       uniprotKB_accession function sequence
protease742_substrate1              C8UEJ9        1        2
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:126: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  print(df["sequence"][0])
2
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:127: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  return df["sequence"][0]
full_aa.
2
<class 'str'>
full_aa len < trim_len: 160.
----------------------protease: 742, S08.071; positive_data: 3/193, ('O00292', 77)--------------------------
uniprot_id: O00292
result01:
<re.Match object; span=(0, 6), match='O00292'>
result02
<re.Match object; span=(0, 6), match='O00292'>
uniprot_id after re: O00292
result.
<re.Match object; span=(0, 6), match='O00292'>
p1: 77
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:99: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['uniprotKB_accession'][0] = uid
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:99: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  df['uniprotKB_accession'][0] = uid
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:114: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df["function"][0] = function[0].text
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:114: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  df["function"][0] = function[0].text
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:122: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df["sequence"][0] = sequence.text
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:122: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  df["sequence"][0] = sequence.text
                       uniprotKB_accession  ...                                           sequence
protease742_substrate2              O00292  ...  MWPLWLCWALWVLPLAGPGAALTEEQLLGSLLRQLQLSEVPVLDRA...

[1 rows x 3 columns]
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:126: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  print(df["sequence"][0])
MWPLWLCWALWVLPLAGPGAALTEEQLLGSLLRQLQLSEVPVLDRADMEKLVIPAHVRAQYVVLLRRSHGDRSRGKRFSQSFREVAGRFLASEASTHLLVFGMEQRLPPNSELVQAVLRLFQEPVPKAALHRHGRLSPRSAQARVTVEWLRVRDDGSNRTSLIDSRLVSVHESGWKAFDVTEAVNFWQQLSRPRQPLLLQVSVQREHLGPLASGAHKLVRFASQGAPAGLGEPQLELHTLDLRDYGAQGDCDPEAPMTEGTRCCRQEMYIDLQGMKWAKNWVLEPPGFLAYECVGTCQQPPEALAFNWPFLGPRQCIASETASLPMIVSIKEGGRTRPQVVSLPNMRVQKCSCASDGALVPRRLQP
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:127: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  return df["sequence"][0]
full_aa.
MWPLWLCWALWVLPLAGPGAALTEEQLLGSLLRQLQLSEVPVLDRADMEKLVIPAHVRAQYVVLLRRSHGDRSRGKRFSQSFREVAGRFLASEASTHLLVFGMEQRLPPNSELVQAVLRLFQEPVPKAALHRHGRLSPRSAQARVTVEWLRVRDDGSNRTSLIDSRLVSVHESGWKAFDVTEAVNFWQQLSRPRQPLLLQVSVQREHLGPLASGAHKLVRFASQGAPAGLGEPQLELHTLDLRDYGAQGDCDPEAPMTEGTRCCRQEMYIDLQGMKWAKNWVLEPPGFLAYECVGTCQQPPEALAFNWPFLGPRQCIASETASLPMIVSIKEGGRTRPQVVSLPNMRVQKCSCASDGALVPRRLQP
<class 'str'>
term: 3
type of term: <class 'int'>
cleave_pattern in p1 - trim_len/2 < 0:
---MWPLWLCWALWVLPLAGPGAALTEEQLLGSLLRQLQLSEVPVLDRADMEKLVIPAHVRAQYVVLLRRSHGDRSRGKRFSQSFREVAGRFLASEASTHLLVFGMEQRLPPNSELVQAVLRLFQEPVPKAALHRHGRLSPRSAQARVTVEWLRVRDDGS
df_cleave_pattern.
   protease_turn  ...                                            full_aa
0            742  ...  MAWLRALLHCLLPWYCALCAAAGSQTPDLRLSGKLHDYVVTVPCST...
2            742  ...  MWPLWLCWALWVLPLAGPGAALTEEQLLGSLLRQLQLSEVPVLDRA...

[2 rows x 8 columns]
df_cleave_pattern.
   protease_turn  ...                                            full_aa
0            742  ...  MAWLRALLHCLLPWYCALCAAAGSQTPDLRLSGKLHDYVVTVPCST...
2            742  ...  MWPLWLCWALWVLPLAGPGAALTEEQLLGSLLRQLQLSEVPVLDRA...

[2 rows x 8 columns]
----------------------protease: 742, S08.071; positive_data: 4/193, ('O08665', 555)--------------------------
uniprot_id: O08665
result01:
<re.Match object; span=(0, 6), match='O08665'>
result02
<re.Match object; span=(0, 6), match='O08665'>
uniprot_id after re: O08665
result.
<re.Match object; span=(0, 6), match='O08665'>
p1: 555
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:99: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['uniprotKB_accession'][0] = uid
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:99: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  df['uniprotKB_accession'][0] = uid
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:114: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df["function"][0] = function[0].text
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:114: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  df["function"][0] = function[0].text
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:122: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df["sequence"][0] = sequence.text
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:122: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  df["sequence"][0] = sequence.text
                       uniprotKB_accession  ...                                           sequence
protease742_substrate3              O08665  ...  MGWFTGIACLFWGVLLTARANYANGKNNVPRLKLSYKEMLESNNVI...

[1 rows x 3 columns]
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:126: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  print(df["sequence"][0])
MGWFTGIACLFWGVLLTARANYANGKNNVPRLKLSYKEMLESNNVITFNGLANSSSYHTFLLDEERSRLYVGAKDHIFSFNLVNIKDFQKIVWPVSYTRRDECKWAGKDILKECANFIKVLEAYNQTHLYACGTGAFHPICTYIEVGHHPEDNIFKLQDSHFENGRGKSPYDPKLLTASLLIDGELYSGTAADFMGRDFAIFRTLGHHHPIRTEQHDSRWLNDPRFISAHLIPESDNPEDDKVYFFFRENAIDGEHSGKATHARIGQICKNDFGGHRSLVNKWTTFLKARLICSVPGPNGIDTHFDELQDVFLMNSKDPKNPIVYGVFTTSSNIFKGSAVCMYSMSDVRRVFLGPYAHRDGPNYQWVPYQGRVPYPRPGTCPSKTFGGFDSTKDLPDDVITFARSHPAMYNPVFPINNRPIMIKTDVNYQFTQIVVDRVDAEDGQYDVMFIGTDVGTVLKVVSVPKETWHDLEEILLEEMTVFREPTTISAMELSTKQQQLYIGSTAGVAQLPLHRCDIYGKACAECCLARDPYCAWDGSSCSRYFPTAKRRTRRQDIRNGDPLTHCSDLQHHDNHHGPSLEERIIYGVENSSTFLECSPKSQRALVYWQFQRRNEDRKEEIRMGDHIIRTEQGLLLRSLQKKDSGNYLCHAVEHGFMQTLLKVTLEVIDTEHLEELLHKDDDGDGSKIKEMSSSMTPSQKVWYRDFMQLINHPNLNTMDEFCEQVWKRDRKQRRQRPGHSQGSSNKWKHMQESKKGRNRRTHEFERAPRSV
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:127: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  return df["sequence"][0]
full_aa.
MGWFTGIACLFWGVLLTARANYANGKNNVPRLKLSYKEMLESNNVITFNGLANSSSYHTFLLDEERSRLYVGAKDHIFSFNLVNIKDFQKIVWPVSYTRRDECKWAGKDILKECANFIKVLEAYNQTHLYACGTGAFHPICTYIEVGHHPEDNIFKLQDSHFENGRGKSPYDPKLLTASLLIDGELYSGTAADFMGRDFAIFRTLGHHHPIRTEQHDSRWLNDPRFISAHLIPESDNPEDDKVYFFFRENAIDGEHSGKATHARIGQICKNDFGGHRSLVNKWTTFLKARLICSVPGPNGIDTHFDELQDVFLMNSKDPKNPIVYGVFTTSSNIFKGSAVCMYSMSDVRRVFLGPYAHRDGPNYQWVPYQGRVPYPRPGTCPSKTFGGFDSTKDLPDDVITFARSHPAMYNPVFPINNRPIMIKTDVNYQFTQIVVDRVDAEDGQYDVMFIGTDVGTVLKVVSVPKETWHDLEEILLEEMTVFREPTTISAMELSTKQQQLYIGSTAGVAQLPLHRCDIYGKACAECCLARDPYCAWDGSSCSRYFPTAKRRTRRQDIRNGDPLTHCSDLQHHDNHHGPSLEERIIYGVENSSTFLECSPKSQRALVYWQFQRRNEDRKEEIRMGDHIIRTEQGLLLRSLQKKDSGNYLCHAVEHGFMQTLLKVTLEVIDTEHLEELLHKDDDGDGSKIKEMSSSMTPSQKVWYRDFMQLINHPNLNTMDEFCEQVWKRDRKQRRQRPGHSQGSSNKWKHMQESKKGRNRRTHEFERAPRSV
<class 'str'>
df_cleave_pattern.
   protease_turn  ...                                            full_aa
0            742  ...  MAWLRALLHCLLPWYCALCAAAGSQTPDLRLSGKLHDYVVTVPCST...
2            742  ...  MWPLWLCWALWVLPLAGPGAALTEEQLLGSLLRQLQLSEVPVLDRA...
3            742  ...  MGWFTGIACLFWGVLLTARANYANGKNNVPRLKLSYKEMLESNNVI...

[3 rows x 8 columns]
df_cleave_pattern.
   protease_turn  ...                                            full_aa
0            742  ...  MAWLRALLHCLLPWYCALCAAAGSQTPDLRLSGKLHDYVVTVPCST...
2            742  ...  MWPLWLCWALWVLPLAGPGAALTEEQLLGSLLRQLQLSEVPVLDRA...
3            742  ...  MGWFTGIACLFWGVLLTARANYANGKNNVPRLKLSYKEMLESNNVI...

[3 rows x 8 columns]
----------------------protease: 742, S08.071; positive_data: 5/193, ('O14672', 213)--------------------------
uniprot_id: O14672
result01:
<re.Match object; span=(0, 6), match='O14672'>
result02
<re.Match object; span=(0, 6), match='O14672'>
uniprot_id after re: O14672
result.
<re.Match object; span=(0, 6), match='O14672'>
p1: 213
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:99: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['uniprotKB_accession'][0] = uid
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:99: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  df['uniprotKB_accession'][0] = uid
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:114: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df["function"][0] = function[0].text
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:114: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  df["function"][0] = function[0].text
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:122: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df["sequence"][0] = sequence.text
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:122: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  df["sequence"][0] = sequence.text
                       uniprotKB_accession  ...                                           sequence
protease742_substrate4              O14672  ...  MVLLRVLILLLSWAAGMGGQYGNPLNKYIRHYEGLSYNVDSLHQKH...

[1 rows x 3 columns]
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:126: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  print(df["sequence"][0])
MVLLRVLILLLSWAAGMGGQYGNPLNKYIRHYEGLSYNVDSLHQKHQRAKRAVSHEDQFLRLDFHAHGRHFNLRMKRDTSLFSDEFKVETSNKVLDYDTSHIYTGHIYGEEGSFSHGSVIDGRFEGFIQTRGGTFYVEPAERYIKDRTLPFHSVIYHEDDINYPHKYGPQGGCADHSVFERMRKYQMTGVEEVTQIPQEEHAANGPELLRKKRTTSAEKNTCQLYIQTDHLFFKYYGTREAVIAQISSHVKAIDTIYQTTDFSGIRNISFMVKRIRINTTADEKDPTNPFRFPNIGVEKFLELNSEQNHDDYCLAYVFTDRDFDDGVLGLAWVGAPSGSSGGICEKSKLYSDGKKKSLNTGIITVQNYGSHVPPKVSHITFAHEVGHNFGSPHDSGTECTPGESKNLGQKENGNYIMYARATSGDKLNNNKFSLCSIRNISQVLEKKRNNCFVESGQPICGNGMVEQGEECDCGYSDQCKDECCFDANQPEGRKCKLKPGKQCSPSQGPCCTAQCAFKSKSEKCRDDSDCAREGICNGFTALCPASDPKPNFTDCNRHTQVCINGQCAGSICEKYGLEECTCASSDGKDDKELCHVCCMKKMDPSTCASTGSVQWSRHFSGRTITLQPGSPCNDFRGYCDVFMRCRLVDADGPLARLKKAIFSPELYENIAEWIVAHWWAVLLMGIALIMLMAGFIKICSVHTPSSNPKLPPPKPLPGTLKRRRPPQPIQQPQRQRPRESYQMGHMRR
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:127: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  return df["sequence"][0]
full_aa.
MVLLRVLILLLSWAAGMGGQYGNPLNKYIRHYEGLSYNVDSLHQKHQRAKRAVSHEDQFLRLDFHAHGRHFNLRMKRDTSLFSDEFKVETSNKVLDYDTSHIYTGHIYGEEGSFSHGSVIDGRFEGFIQTRGGTFYVEPAERYIKDRTLPFHSVIYHEDDINYPHKYGPQGGCADHSVFERMRKYQMTGVEEVTQIPQEEHAANGPELLRKKRTTSAEKNTCQLYIQTDHLFFKYYGTREAVIAQISSHVKAIDTIYQTTDFSGIRNISFMVKRIRINTTADEKDPTNPFRFPNIGVEKFLELNSEQNHDDYCLAYVFTDRDFDDGVLGLAWVGAPSGSSGGICEKSKLYSDGKKKSLNTGIITVQNYGSHVPPKVSHITFAHEVGHNFGSPHDSGTECTPGESKNLGQKENGNYIMYARATSGDKLNNNKFSLCSIRNISQVLEKKRNNCFVESGQPICGNGMVEQGEECDCGYSDQCKDECCFDANQPEGRKCKLKPGKQCSPSQGPCCTAQCAFKSKSEKCRDDSDCAREGICNGFTALCPASDPKPNFTDCNRHTQVCINGQCAGSICEKYGLEECTCASSDGKDDKELCHVCCMKKMDPSTCASTGSVQWSRHFSGRTITLQPGSPCNDFRGYCDVFMRCRLVDADGPLARLKKAIFSPELYENIAEWIVAHWWAVLLMGIALIMLMAGFIKICSVHTPSSNPKLPPPKPLPGTLKRRRPPQPIQQPQRQRPRESYQMGHMRR
<class 'str'>
df_cleave_pattern.
   protease_turn  ...                                            full_aa
0            742  ...  MAWLRALLHCLLPWYCALCAAAGSQTPDLRLSGKLHDYVVTVPCST...
2            742  ...  MWPLWLCWALWVLPLAGPGAALTEEQLLGSLLRQLQLSEVPVLDRA...
3            742  ...  MGWFTGIACLFWGVLLTARANYANGKNNVPRLKLSYKEMLESNNVI...
4            742  ...  MVLLRVLILLLSWAAGMGGQYGNPLNKYIRHYEGLSYNVDSLHQKH...

[4 rows x 8 columns]
df_cleave_pattern.
   protease_turn  ...                                            full_aa
0            742  ...  MAWLRALLHCLLPWYCALCAAAGSQTPDLRLSGKLHDYVVTVPCST...
2            742  ...  MWPLWLCWALWVLPLAGPGAALTEEQLLGSLLRQLQLSEVPVLDRA...
3            742  ...  MGWFTGIACLFWGVLLTARANYANGKNNVPRLKLSYKEMLESNNVI...
4            742  ...  MVLLRVLILLLSWAAGMGGQYGNPLNKYIRHYEGLSYNVDSLHQKH...

[4 rows x 8 columns]
----------------------protease: 742, S08.071; positive_data: 6/193, ('O15072', 249)--------------------------
uniprot_id: O15072
result01:
<re.Match object; span=(0, 6), match='O15072'>
result02
<re.Match object; span=(0, 6), match='O15072'>
uniprot_id after re: O15072
result.
<re.Match object; span=(0, 6), match='O15072'>
p1: 249
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:99: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['uniprotKB_accession'][0] = uid
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:99: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  df['uniprotKB_accession'][0] = uid
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:114: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df["function"][0] = function[0].text
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:114: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  df["function"][0] = function[0].text
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:122: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df["sequence"][0] = sequence.text
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:122: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  df["sequence"][0] = sequence.text
                       uniprotKB_accession  ...                                           sequence
protease742_substrate5              O15072  ...  MVLLSLWLIAAALVEVRTSADGQAGNEEMVQIDLPIKRYREYELVT...

[1 rows x 3 columns]
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:126: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  print(df["sequence"][0])
MVLLSLWLIAAALVEVRTSADGQAGNEEMVQIDLPIKRYREYELVTPVSTNLEGRYLSHTLSASHKKRSARDVSSNPEQLFFNITAFGKDFHLRLKPNTQLVAPGAVVEWHETSLVPGNITDPINNHQPGSATYRIRRTEPLQTNCAYVGDIVDIPGTSVAISNCDGLAGMIKSDNEEYFIEPLERGKQMEEEKGRIHVVYKRSAVEQAPIDMSKDFHYRESDLEGLDDLGTVYGNIHQQLNETMRRRRHAGENDYNIEVLLGVDDSVVRFHGKEHVQNYLLTLMNIVNEIYHDESLGVHINVVLVRMIMLGYAKSISLIERGNPSRSLENVCRWASQQQRSDLNHSEHHDHAIFLTRQDFGPAGMQGYAPVTGMCHPVRSCTLNHEDGFSSAFVVAHETGHVLGMEHDGQGNRCGDETAMGSVMAPLVQAAFHRYHWSRCSGQELKRYIHSYDCLLDDPFDHDWPKLPELPGINYSMDEQCRFDFGVGYKMCTAFRTFDPCKQLWCSHPDNPYFCKTKKGPPLDGTECAAGKWCYKGHCMWKNANQQKQDGNWGSWTKFGSCSRTCGTGVRFRTRQCNNPMPINGGQDCPGVNFEYQLCNTEECQKHFEDFRAQQCQQRNSHFEYQNTKHHWLPYEHPDPKKRCHLYCQSKETGDVAYMKQLVHDGTHCSYKDPYSICVRGECVKVGCDKEIGSNKVEDKCGVCGGDNSHCRTVKGTFTRTPRKLGYLKMFDIPPGARHVLIQEDEASPHILAIKNQATGHYILNGKGEEAKSRTFIDLGVEWDYNIEDDIESLHTDGPLHDPVIVLIIPQENDTRSSLTYKYIIHEDSVPTINSNNVIQEELDTFEWALKSWSQCSKPCGGGFQYTKYGCRRKSDNKMVHRSFCEANKKPKPIRRMCNIQECTHPLWVAEEWEHCTKTCGSSGYQLRTVRCLQPLLDGTNRSVHSKYCMGDRPESRRPCNRVPCPAQWKTGPWSECSVTCGEGTEVRQVLCRAGDHCDGEKPESVRACQLPPCNDEPCLGDKSIFCQMEVLARYCSIPGYNKLCCESCSKRSSTLPPPYLLEAAETHDDVISNPSDLPRSLVMPTSLVPYHSETPAKKMSLSSISSVGGPNAYAAFRPNSKPDGANLRQRSAQQAGSKTVRLVTVPSSPPTKRVHLSSASQMAAASFFAASDSIGASSQARTSKKDGKIIDNRRPTRSSTLER
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:127: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  return df["sequence"][0]
full_aa.
MVLLSLWLIAAALVEVRTSADGQAGNEEMVQIDLPIKRYREYELVTPVSTNLEGRYLSHTLSASHKKRSARDVSSNPEQLFFNITAFGKDFHLRLKPNTQLVAPGAVVEWHETSLVPGNITDPINNHQPGSATYRIRRTEPLQTNCAYVGDIVDIPGTSVAISNCDGLAGMIKSDNEEYFIEPLERGKQMEEEKGRIHVVYKRSAVEQAPIDMSKDFHYRESDLEGLDDLGTVYGNIHQQLNETMRRRRHAGENDYNIEVLLGVDDSVVRFHGKEHVQNYLLTLMNIVNEIYHDESLGVHINVVLVRMIMLGYAKSISLIERGNPSRSLENVCRWASQQQRSDLNHSEHHDHAIFLTRQDFGPAGMQGYAPVTGMCHPVRSCTLNHEDGFSSAFVVAHETGHVLGMEHDGQGNRCGDETAMGSVMAPLVQAAFHRYHWSRCSGQELKRYIHSYDCLLDDPFDHDWPKLPELPGINYSMDEQCRFDFGVGYKMCTAFRTFDPCKQLWCSHPDNPYFCKTKKGPPLDGTECAAGKWCYKGHCMWKNANQQKQDGNWGSWTKFGSCSRTCGTGVRFRTRQCNNPMPINGGQDCPGVNFEYQLCNTEECQKHFEDFRAQQCQQRNSHFEYQNTKHHWLPYEHPDPKKRCHLYCQSKETGDVAYMKQLVHDGTHCSYKDPYSICVRGECVKVGCDKEIGSNKVEDKCGVCGGDNSHCRTVKGTFTRTPRKLGYLKMFDIPPGARHVLIQEDEASPHILAIKNQATGHYILNGKGEEAKSRTFIDLGVEWDYNIEDDIESLHTDGPLHDPVIVLIIPQENDTRSSLTYKYIIHEDSVPTINSNNVIQEELDTFEWALKSWSQCSKPCGGGFQYTKYGCRRKSDNKMVHRSFCEANKKPKPIRRMCNIQECTHPLWVAEEWEHCTKTCGSSGYQLRTVRCLQPLLDGTNRSVHSKYCMGDRPESRRPCNRVPCPAQWKTGPWSECSVTCGEGTEVRQVLCRAGDHCDGEKPESVRACQLPPCNDEPCLGDKSIFCQMEVLARYCSIPGYNKLCCESCSKRSSTLPPPYLLEAAETHDDVISNPSDLPRSLVMPTSLVPYHSETPAKKMSLSSISSVGGPNAYAAFRPNSKPDGANLRQRSAQQAGSKTVRLVTVPSSPPTKRVHLSSASQMAAASFFAASDSIGASSQARTSKKDGKIIDNRRPTRSSTLER
<class 'str'>
df_cleave_pattern.
   protease_turn  ...                                            full_aa
0            742  ...  MAWLRALLHCLLPWYCALCAAAGSQTPDLRLSGKLHDYVVTVPCST...
2            742  ...  MWPLWLCWALWVLPLAGPGAALTEEQLLGSLLRQLQLSEVPVLDRA...
3            742  ...  MGWFTGIACLFWGVLLTARANYANGKNNVPRLKLSYKEMLESNNVI...
4            742  ...  MVLLRVLILLLSWAAGMGGQYGNPLNKYIRHYEGLSYNVDSLHQKH...
5            742  ...  MVLLSLWLIAAALVEVRTSADGQAGNEEMVQIDLPIKRYREYELVT...

[5 rows x 8 columns]
df_cleave_pattern.
   protease_turn  ...                                            full_aa
0            742  ...  MAWLRALLHCLLPWYCALCAAAGSQTPDLRLSGKLHDYVVTVPCST...
2            742  ...  MWPLWLCWALWVLPLAGPGAALTEEQLLGSLLRQLQLSEVPVLDRA...
3            742  ...  MGWFTGIACLFWGVLLTARANYANGKNNVPRLKLSYKEMLESNNVI...
4            742  ...  MVLLRVLILLLSWAAGMGGQYGNPLNKYIRHYEGLSYNVDSLHQKH...
5            742  ...  MVLLSLWLIAAALVEVRTSADGQAGNEEMVQIDLPIKRYREYELVT...

[5 rows x 8 columns]
----------------------protease: 742, S08.071; positive_data: 7/193, ('O43184', 207)--------------------------
uniprot_id: O43184
result01:
<re.Match object; span=(0, 6), match='O43184'>
result02
<re.Match object; span=(0, 6), match='O43184'>
uniprot_id after re: O43184
result.
<re.Match object; span=(0, 6), match='O43184'>
p1: 207
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:99: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['uniprotKB_accession'][0] = uid
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:99: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  df['uniprotKB_accession'][0] = uid
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:114: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df["function"][0] = function[0].text
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:114: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  df["function"][0] = function[0].text
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:122: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df["sequence"][0] = sequence.text
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:122: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  df["sequence"][0] = sequence.text
                       uniprotKB_accession  ...                                           sequence
protease742_substrate6              O43184  ...  MAARPLPVSPARALLLALAGALLAPCEARGVSLWNQGRADEVVSAS...

[1 rows x 3 columns]
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:126: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  print(df["sequence"][0])
MAARPLPVSPARALLLALAGALLAPCEARGVSLWNQGRADEVVSASVGSGDLWIPVKSFDSKNHPEVLNIRLQRESKELIINLERNEGLIASSFTETHYLQDGTDVSLARNYTVILGHCYYHGHVRGYSDSAVSLSTCSGLRGLIVFENESYVLEPMKSATNRYKLFPAKKLKSVRGSCGSHHNTPNLAAKNVFPPPSQTWARRHKRETLKATKYVELVIVADNREFQRQGKDLEKVKQRLIEIANHVDKFYRPLNIRIVLVGVEVWNDMDKCSVSQDPFTSLHEFLDWRKMKLLPRKSHDNAQLVSGVYFQGTTIGMAPIMSMCTADQSGGIVMDHSDNPLGAAVTLAHELGHNFGMNHDTLDRGCSCQMAVEKGGCIMNASTGYPFPMVFSSCSRKDLETSLEKGMGVCLFNLPEVRESFGGQKCGNRFVEEGEECDCGEPEECMNRCCNATTCTLKPDAVCAHGLCCEDCQLKPAGTACRDSSNSCDLPEFCTGASPHCPANVYLHDGHSCQDVDGYCYNGICQTHEQQCVTLWGPGAKPAPGICFERVNSAGDPYGNCGKVSKSSFAKCEMRDAKCGKIQCQGGASRPVIGTNAVSIETNIPLQQGGRILCRGTHVYLGDDMPDPGLVLAGTKCADGKICLNRQCQNISVFGVHECAMQCHGRGVCNNRKNCHCEAHWAPPFCDKFGFGGSTDSGPIRQADNQGLTIGILVTILCLLAAGFVVYLKRKTLIRLLFTNKKTTIEKLRCVRPSRPPRGFQPCQAHLGHLGKGLMRKPPDSYPPKDNPRRLLQCQNVDISRPLNGLNVPQPQSTQRVLPPLHRAPRAPSVPARPLPAKPALRQAQGTCKPNPPQKPLPADPLARTTRLTHALARTPGQWETGLRLAPLRPAPQYPHQVPRSTHTAYIK
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:127: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  return df["sequence"][0]
full_aa.
MAARPLPVSPARALLLALAGALLAPCEARGVSLWNQGRADEVVSASVGSGDLWIPVKSFDSKNHPEVLNIRLQRESKELIINLERNEGLIASSFTETHYLQDGTDVSLARNYTVILGHCYYHGHVRGYSDSAVSLSTCSGLRGLIVFENESYVLEPMKSATNRYKLFPAKKLKSVRGSCGSHHNTPNLAAKNVFPPPSQTWARRHKRETLKATKYVELVIVADNREFQRQGKDLEKVKQRLIEIANHVDKFYRPLNIRIVLVGVEVWNDMDKCSVSQDPFTSLHEFLDWRKMKLLPRKSHDNAQLVSGVYFQGTTIGMAPIMSMCTADQSGGIVMDHSDNPLGAAVTLAHELGHNFGMNHDTLDRGCSCQMAVEKGGCIMNASTGYPFPMVFSSCSRKDLETSLEKGMGVCLFNLPEVRESFGGQKCGNRFVEEGEECDCGEPEECMNRCCNATTCTLKPDAVCAHGLCCEDCQLKPAGTACRDSSNSCDLPEFCTGASPHCPANVYLHDGHSCQDVDGYCYNGICQTHEQQCVTLWGPGAKPAPGICFERVNSAGDPYGNCGKVSKSSFAKCEMRDAKCGKIQCQGGASRPVIGTNAVSIETNIPLQQGGRILCRGTHVYLGDDMPDPGLVLAGTKCADGKICLNRQCQNISVFGVHECAMQCHGRGVCNNRKNCHCEAHWAPPFCDKFGFGGSTDSGPIRQADNQGLTIGILVTILCLLAAGFVVYLKRKTLIRLLFTNKKTTIEKLRCVRPSRPPRGFQPCQAHLGHLGKGLMRKPPDSYPPKDNPRRLLQCQNVDISRPLNGLNVPQPQSTQRVLPPLHRAPRAPSVPARPLPAKPALRQAQGTCKPNPPQKPLPADPLARTTRLTHALARTPGQWETGLRLAPLRPAPQYPHQVPRSTHTAYIK
<class 'str'>
df_cleave_pattern.
   protease_turn  ...                                            full_aa
0            742  ...  MAWLRALLHCLLPWYCALCAAAGSQTPDLRLSGKLHDYVVTVPCST...
2            742  ...  MWPLWLCWALWVLPLAGPGAALTEEQLLGSLLRQLQLSEVPVLDRA...
3            742  ...  MGWFTGIACLFWGVLLTARANYANGKNNVPRLKLSYKEMLESNNVI...
4            742  ...  MVLLRVLILLLSWAAGMGGQYGNPLNKYIRHYEGLSYNVDSLHQKH...
5            742  ...  MVLLSLWLIAAALVEVRTSADGQAGNEEMVQIDLPIKRYREYELVT...
6            742  ...  MAARPLPVSPARALLLALAGALLAPCEARGVSLWNQGRADEVVSAS...

[6 rows x 8 columns]
df_cleave_pattern.
   protease_turn  ...                                            full_aa
0            742  ...  MAWLRALLHCLLPWYCALCAAAGSQTPDLRLSGKLHDYVVTVPCST...
2            742  ...  MWPLWLCWALWVLPLAGPGAALTEEQLLGSLLRQLQLSEVPVLDRA...
3            742  ...  MGWFTGIACLFWGVLLTARANYANGKNNVPRLKLSYKEMLESNNVI...
4            742  ...  MVLLRVLILLLSWAAGMGGQYGNPLNKYIRHYEGLSYNVDSLHQKH...
5            742  ...  MVLLSLWLIAAALVEVRTSADGQAGNEEMVQIDLPIKRYREYELVT...
6            742  ...  MAARPLPVSPARALLLALAGALLAPCEARGVSLWNQGRADEVVSAS...

[6 rows x 8 columns]
----------------------protease: 742, S08.071; positive_data: 8/193, ('O43508-2', 184)--------------------------
uniprot_id: O43508-2
result01:
None
result02
<re.Match object; span=(0, 6), match='O43508'>
uniprot_id after re: O43508
result.
<re.Match object; span=(0, 6), match='O43508'>
p1: 184
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:99: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['uniprotKB_accession'][0] = uid
C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py:99: FutureWarning: Series.__setitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To set a value by position, use `ser.iloc[pos] = value`
  df['uniprotKB_accession'][0] = uid
Traceback (most recent call last):
  File "C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py", line 717, in <module>
    main()
  File "C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py", line 39, in main
    create_posi_nega_dataset(merops_code_mece, cur, error_list, df_full_aa_shorter_than_trim_len, trim_len)
  File "C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py", line 202, in create_posi_nega_dataset
    df_cleave_pattern = create_posi_dataset(protease, list_subs, df_cleave_pattern, protease_turn, error_list, df_full_aa_shorter_than_trim_len, df_uniprot_id_error, trim_len)
  File "C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py", line 312, in create_posi_dataset
    full_aa = aaseq_from_uid(uniprot_id, protease_turn, substrate_turn)
  File "C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git\01-02-05_creating_positive&negative_data_160aa_refactoring_20251215.py", line 104, in aaseq_from_uid
    f = urlopen(url)
  File "C:\Users\miyazakilab\anaconda3\lib\urllib\request.py", line 214, in urlopen
    return opener.open(url, data, timeout)
  File "C:\Users\miyazakilab\anaconda3\lib\urllib\request.py", line 523, in open
    response = meth(req, response)
  File "C:\Users\miyazakilab\anaconda3\lib\urllib\request.py", line 632, in http_response
    response = self.parent.error(
  File "C:\Users\miyazakilab\anaconda3\lib\urllib\request.py", line 555, in error
    result = self._call_chain(*args)
  File "C:\Users\miyazakilab\anaconda3\lib\urllib\request.py", line 494, in _call_chain
    result = func(*args)
  File "C:\Users\miyazakilab\anaconda3\lib\urllib\request.py", line 747, in http_error_302
    return self.parent.open(new, timeout=req.timeout)
  File "C:\Users\miyazakilab\anaconda3\lib\urllib\request.py", line 523, in open
    response = meth(req, response)
  File "C:\Users\miyazakilab\anaconda3\lib\urllib\request.py", line 632, in http_response
    response = self.parent.error(
  File "C:\Users\miyazakilab\anaconda3\lib\urllib\request.py", line 555, in error
    result = self._call_chain(*args)
  File "C:\Users\miyazakilab\anaconda3\lib\urllib\request.py", line 494, in _call_chain
    result = func(*args)
  File "C:\Users\miyazakilab\anaconda3\lib\urllib\request.py", line 747, in http_error_302
    return self.parent.open(new, timeout=req.timeout)
  File "C:\Users\miyazakilab\anaconda3\lib\urllib\request.py", line 517, in open
    response = self._open(req, data)
  File "C:\Users\miyazakilab\anaconda3\lib\urllib\request.py", line 534, in _open
    result = self._call_chain(self.handle_open, protocol, protocol +
  File "C:\Users\miyazakilab\anaconda3\lib\urllib\request.py", line 494, in _call_chain
    result = func(*args)
  File "C:\Users\miyazakilab\anaconda3\lib\urllib\request.py", line 1389, in https_open
    return self.do_open(http.client.HTTPSConnection, req,
  File "C:\Users\miyazakilab\anaconda3\lib\urllib\request.py", line 1346, in do_open
    h.request(req.get_method(), req.selector, req.data, headers,
  File "C:\Users\miyazakilab\anaconda3\lib\http\client.py", line 1285, in request
    self._send_request(method, url, body, headers, encode_chunked)
  File "C:\Users\miyazakilab\anaconda3\lib\http\client.py", line 1331, in _send_request
    self.endheaders(body, encode_chunked=encode_chunked)
  File "C:\Users\miyazakilab\anaconda3\lib\http\client.py", line 1280, in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
  File "C:\Users\miyazakilab\anaconda3\lib\http\client.py", line 1040, in _send_output
    self.send(msg)
  File "C:\Users\miyazakilab\anaconda3\lib\http\client.py", line 980, in send
    self.connect()
  File "C:\Users\miyazakilab\anaconda3\lib\http\client.py", line 1447, in connect
    super().connect()
  File "C:\Users\miyazakilab\anaconda3\lib\http\client.py", line 946, in connect
    self.sock = self._create_connection(
  File "C:\Users\miyazakilab\anaconda3\lib\socket.py", line 832, in create_connection
    sock.connect(sa)
KeyboardInterrupt
^C
(base) C:\Users\miyazakilab\Documents\workstation_ysasaki\program\protease_predictor_git>



2	742	S08.071	2	O00292	77	366	#NAME?
